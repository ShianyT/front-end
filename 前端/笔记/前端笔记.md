# HTML

#### 1.【基础标签】

* 标题标签\<h1>-\<h6>
* 段落标签\<p>
* 换行标签\<br/>

#### 2.【文本格式化标签】

* **加粗\<strong>/\<b>**
* **倾斜\<em>/\<i>**
* 删除线\<del>/\<s>
* 下划线\<ins>/\<u>

#### 3.【盒子】

* 大盒子\<div>
* 小盒子\<span>

#### 4.【图像标签\<img>】

* `<img src="路径" alt="替换文本" titile="提示文本" width="宽度" height="高度" border="边框粗细"/>`

#### 5.【超链接标签\<a>】

* `<a href="跳转目标" target="目标窗口的弹出方式"> 文本或图像 </a>`

#### 6.【注释\<!-- 注释语句 -->】

#### 【特殊字符】

* 空格符\&nbsp;
* 大于号\&lt;
* 小于号\&gt;

#### 7.【表格标签】

* 基本语法

  ```html
  <table>		// 定义表格标签
  	<tr>	// 定义表格的行
          <th>表头单元格</th>		 // 定义表格的表头	
          <td>单元格内的文字</td>	// 定义表格的单元格
  	</tr>
  </table>`
  ```

* 表格结构标签(放在\<table>\</table>标签中)

  * 表格头部区域\<thead>
  * 表格主体区域\<tbody>

* 合并单元格

  * 跨行合并 rowspan="合并单元格的个数"
  * 跨列合并 colspan="合并单元格的个数"

#### 8.【列表标签】

* 无序列表

  ```html
  <ul>
  	<li>列表项1</li>
  	<li>列表项2</li>
  	<li>列表项3</li>
  	...
  </ul>
  ```

* 有序列表

  ```html
  <ol>
  	<li>列表项1</li>
  	<li>列表项2</li>
  	<li>列表项3</li>
  	...
  </ol>
  ```

* 自定义列表

  ```html
  <dl>
  	<dt>名词1</dt>
  	<dd>名词1解释1</dd>
  	<dd>名词1解释2</dd>
      <dt>名词2</dt>
      ...
  </dl>
  ```

#### 9.【表单标签】

* 表单域\<from>：`<form action=“url地址” method=“提交方式” name=“表单域名称">各种表单元素控件</form>`

* 表单控件

  * 输入表单元素\<input>：

    `<input type="属性值" name="该元素名称" value="值" checked="首次是否选中" maxlength="输入的最大长度"/>`

    * type属性值

      * 上传文件file
      * 隐藏的输入字段hidden
      * 图像提交image
      * 密码字段password
      * 按钮button
      * 单选按钮radio
      * 复选框checkbox
      * 重置按钮reset
      * 提交按钮submit
      * 文本框text

    * \<label>：绑定表单元素

      ```html
      <label for="sex">男</label> // 当点击"男"时，会自动跳转到对应的表单标签
      <input type="radio" name="sex" id="sex" />
      ```

  * 下拉列表标签\<select>

    ```html
    <select>
    	<option>选项1</option>
    	<option>选项2</option>
    	<option>选项3</option>
    	...
    </select>
    ```

  * 多行文本输入标签\<textarea>：`<textarea rows="显示的行数" cols="每行中的字符数">文本内容</textarea>`

#### 10.【语义化标签】

* \<header>头部标签、\<nav>导航标签、\<article>内容标签、\<section>定义文档某个区域、\<aside>侧边栏标签、\<footer>尾部标签
* 特点：
  * 这种语义化标准主要是针对搜索引擎的
  * 这些新标签页面中可以使用多次
  * 在 IE9 中，需要把这些元素转换为块级元素

#### 11.【多媒体标签】

* \<audio>音频

  ```css
  <audio src="文件地址" controls="controls"></audio>
  
  <audio controls="controls" >
  	<source src="happy.mp3" type="audio/mpeg" >
  	<source src="happy.ogg" type="audio/ogg" >
  	您的浏览器暂不支持 <audio> 标签。
  </audio>
  ```

* \<video>视频

  ```html
  <video src="文件地址" controls="controls"></video>
  
  <video controls="controls" width="300">
  	<source src="move.ogg" type="video/ogg" >
  	<source src="move.mp4" type="video/mp4" >
  	您的浏览器暂不支持 <video> 标签播放视频
  </ video >
  ```

* 多媒体标签总结

  * 音频标签和视频标签使用方式基本一致
  * 浏览器支持情况不同
  * 谷歌浏览器把音频和视频自动播放禁止了
  * 我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过JavaScript解决）
  * 视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性

#### 12.【新增input类型】

* type="number"：限制用户输入必须为数字类型
* type="tel"：限制用户输入必须为手机号码
* type="search"：搜索框

#### 13.【新增表单属性】

* <img src="C:\Users\wenshuyan\AppData\Roaming\Typora\typora-user-images\image-20250403133041256.png" alt="image-20250403133041256" style="zoom:80%;" />
* 可以通过以下设置方式修改placeholder里面的字体颜色：`input::placeholder { color: pink; }`





# Emmet语法

### 1.【快速生成html】

* 生成标签：输入标签名 + tab键
* 生成多个相同标签：标签名*n + tab键，快速生成n个该标签
* 父子关系标签：ul > li
* 兄弟关系标签：div + p
* 生成带类/id名的标签：.demo 或者 # two + tab键
* 生成有顺序的类名：自增符号$
* 生成的标签内部写内容：{}

### 2.【快速生成CSS】

* w200：width: 200px;

* lh26px：line-height: 26px

### 3.【快速格式化】

* shift + alt + f







# CSS

### 1.【选择器】

#### 1、基础选择器

* 标签选择器：HTML标签名称做选择器

* 类选择器：html标签中添加class属性，"."定义

  ```css
  .类名 {			// 类前面的"."不能忘记
      属性1:属性值1;
  }
  
  <div class='res'></div> // html标签要使用class属性
  <<div class='res font20'></div> // 多类名，用空格隔开
  ```

* id选择器：html标签中用id属性来设置，"#"定义

  ```css
  #id名 {
      属性1:属性值1;
  }
  <div id='nav'></div>
  // id 属性只能在每个 HTML 文档中出现一次,也只能调用一次
  ```

* 通配符选择器：选取页面所有元素(标签)，"*"定义

  ```css
  * {			
  	margin: 0;
  	padding: 0;
  }
  // 一般不适用，特殊情况才使用，如清除所有的元素标签的内外边距
  ```

#### 2、复合选择器

* 后代选择器(包含选择器)

  ```css
  // 语法：元素1 元素2 { 样式声明 }
  ul li { 样式声明 } // 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可
  ```

* 子元素选择器(子选择器)

  ```css
  // 语法：元素1 > 元素2 { 样式声明 }
  div > p { 样式声明 } // 只选择 div 里面最近一级 p 标签元素
  ```

* 并集选择器：取和

  ```css
  // 语法：元素1,元素2 { 样式声明 }
  ui,div { 样式声明 } // 选择ul和div标签
  ```

* 伪类选择器：用于向某些选择器添加特殊效果

  * 链接伪类选择器：为了保证该选择器生效，必须按照如下的顺序来写

    ```css
    a:link // 选择所有未被访问的标签
    a:visited // 选择所有已被访问的链接
    a:hover // 选择鼠标指针位于其上的链接
    a:active // 选择活动链接(鼠标按下未弹起的链接)
    ```

  * :focus 伪类选择器：选取获得焦点的表单元素，一般都是\<input>

    ```css
    input:focus {
    	background-color:yellow;
    }
    ```

#### 3、新增的选择器

* 属性选择器：根据元素的特定属性来选择元素

  * ``` css
    // E元素 | att属性
    E[att] // 具有att属性的E元素
    E[att="val"] // 具有att属性且等于val值的E元素
    E[att^="val"] // 具有att属性且val开头的E元素
    E[att$="val"] // 具有att属性且val结尾的E元素
    E[att*="val"] // 具有att属性且含有val的E元素
    ```

  * 权重为10

* 结构伪类选择器：根据文档结构来选择元素，通常为父级选择子级

  * ![06-HTML5 和 CSS3 的新特性](images\06-HTML5 和 CSS3 的新特性.png)

  * nth-child(n)：对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配

    * n 可以是数字，选择第 n (1——∞)个子元素， 

    * n 可以是关键字：even 偶数，odd 奇数 

    * n 可以是公式：常见的公式如下 ( 如果n是公式，则从0开始计算，但是第 0 个元素或者超出了元素的个数会被忽略 ) 

      ![06-HTML5 和 CSS3 的新特性2](images\06-HTML5 和 CSS3 的新特性2.png)

  * nth-of-type(n)：对父元素里面指定子元素进行排序选择。 先去匹配E，然后再根据 E 找第n个孩子 

  * 权重为10

* 伪元素选择器：利用CSS创建新标签元素，简化HTML结构。 

  * <img src="images\06-HTML5 和 CSS3 的新特性03.png" alt="06-HTML5 和 CSS3 的新特性03" style="zoom:80%;" />
  * 语法：`element::before { content: ''; } `
  * before 和 after 创建一个元素，但是属于行内元素 
  * 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 
  * before 和 after **必须有 content 属性** 
  * before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素 
  * 伪元素选择器和标签选择器一样，权重为 1 

### 2.【属性】

#### 1、字体属性

* font-family：文本字体系列，多个值用" , "分隔

* font-size：字体大小，单位px(像素)

* font-weight：字体粗细，属性值有`normal不加粗；bold加粗；100-900(400等同normal,700等同bold,不跟单位)`

* font-style：文本风格，`normal标准字体；italic斜体`

* 字体复合属性：必须按照下列顺序书写，不能更换顺序，用空格隔开，必须保留size和family属性，否则失效

  ```css
  body {
      font: font-style font-weight font-size/line-height font-family;
  }
  ```

#### 2、文本属性

* color：文本颜色，`预定义颜色(red、green等)；十六进制(#FF0000)；RGB代码(rgb(255,0,0)或rgb(100%,0%,0%))`
* text-align：文本内容水平对齐方式，`left左对齐；right右对齐；center居中对齐`
* text-decoration：装饰文本，`none；underline下划线；overline上划线；line-through删除线`
* text-indent：指定文本的第一行缩进，`10px(像素值)；1em(即一个文字大小)`
* line-height：行间距，`line-height: 26px(整个文本的高度)`

### 3.【引入方式】

* 行内样式表（行内式）：直接在html标签中用style属性设定`<div style="color: red; font-size: 12px;"></div>`
* 内部样式表（嵌入式）：css代码放到\<style>标签中
* 外部样式表（链接式）：单独写到css文件中，用\<link>标签引入`<link rel="stylesheet" href="css文件路径">`；rel需要指定为"stylesheet"，表明被链接的是一个样式表文件

### 4.【元素显示模式】

**1、块元素**

* 常见的块元素有\<h1>~\<h6>、\<p>、\<div>、\<ul>、\<ol>、\<li>等，其中 \<div> 标签是最典型的块元素
* 特点：独占一行、宽高以及内外边距可以控制、默认宽是父级的100%

**2、行内元素**

* 常见的行内元素有 \<a>、\<strong>、\<b>、\<em>、\<i>、\<del>、\<s>、\<ins>、\<u>、\<span>等，其中\<span> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。
* 特点：一行显示多个、无法直接设置宽高、默认宽取决于内容

**3、行内块元素**

* \<img />、\<input />、\<td>，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。
* 特点：一行显示多个，但会有空白缝隙、默认宽取决于内容、宽高内外边距可控

**4、元素显示模式转换**

* 转换为块元素：`display:block`
* 转换为行内元素：`display:inline`
* 转换为行内块：`display:inline-block`

**5、单行文字垂直居中**

CSS 没有给我们提供文字垂直居中的代码

解决方案: 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中

### 5.【背景】

* background-color：元素背景颜色；`默认值transparent(透明)、颜色值`

* background-image：元素背景图像；`默认值none(无图)、url(url)(括号里跟路径，不带引号)`

* background-repeat：背景平铺；`默认值repeat(纵向和横向平铺)、no-repeat(不平铺)、repeat-x(横向平铺)、repeat-y(纵向平铺)`

* background-position：改变图片在背景中的位置；`x y`

  * 参数是方位名词：top | center | bottom | left | center | right，没有前后顺序之分
  * 参数是精确单位：x y；x 居中；百分数| 浮点数和单位标识符
  * 参数是混合单位：精确单位和方位名词混用

* background-attachment：设置背景图像是否固定或者随着页面的其余部分滚动；`scroll(滚动) | fixed(固定)`

* 背景复合写法：background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置；

  ```css
  background: transparent url(image.jpg) repeat-y fixed top ;
  ```

* 背景色半透明：`background: rgba(0, 0, 0, 0.3);`

  * 最后一个参数是 alpha 透明度，取值范围在 0~1之间
  * 可以把0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3);

### 6.【三大特性】

#### 1、层叠性

* 定义：相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。
* 层叠行原则：样式冲突的，后面层叠掉前面

#### 2、继承性

* 定义：子标签会继承父标签的某些样式，如文本颜色和字号。

* 行高的继承性

  * ```css
    body {
    	font:12px/1.5 Microsoft YaHei；
    }
    ```

  * 行高可以跟单位也可以不跟单位

  * 如果子元素没有设置行高，则会继承父元素的行高为 1.5；此时子元素的行高是：当前子元素的文字大小 * 1.5

  * body 行高 1.5 这样写法最大的优势就是里面**子元素可以根据自己文字大小自动调整行高**

#### 3、优先级

* 定义：当同一个元素指定多个选择器，就会有优先级的产生。

* | 选择器               | 选择器权重 |
  | -------------------- | ---------- |
  | 继承 / *             | 0，0，0，0 |
  | 元素选择器           | 0，0，0，1 |
  | 类选择器，伪类选择器 | 0，0，1，0 |
  | ID选择器             | 0，1，0，0 |
  | 行内样式 style=""    | 1，0，0，0 |
  | !important 重要的    | ∞无穷大    |

* 注意点

  1. 权重是有4组数字组成,但是不会有进位。
  2. 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推..
  3. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。
  4. 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为
  1000, !important 无穷大.
  5. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。

* 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。

  * div ul li ------> 0,0,0,3
  * .nav ul li ------> 0,0,1,2
  * a:hover -----—> 0,0,1,1
  * .nav a ------> 0,0,1,1

### 7.【盒子模型】

#### 1、盒子模型组成

* 定义：就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。
* CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和实际内容
* ![image-20250323193008871](images\image-20250323193008871.png)

#### 2、边框(border)

* 组成：边框宽度(粗细) 边框样式 边框颜色
* 语法：`border : border-width(粗细，px) || border-style(样式) || border-color(颜色)`
* border-style：none(默认值)，solid(单实线)，dashed(虚线)，dotted(点线)
* 简写：`border: 1px solid red; 没有顺序`
* 分开设置：`border-top: 1px solid red; /* 只设定上边框， 其余同理 */`
* border-collapse：浏览器绘制表格边框的方式。它控制相邻单元格的边框`border-collapse:collapse; 相邻边框合并在一起`
* border会影响盒子实际大小，解决：测量盒子大小时不量边框；如果包含边框,则需要 width/height 减去边框宽度

#### 3、内边距(padding)

* 属性：padding-left | padding-right | padding-top | padding-bottom
* 简写
  * `padding: 5px` 1个值，上下左右5px
  * `padding: 5px 10px` 2个值，上下5px，左右10px
  * `padding: 5px 10px 20px` 3个值，上5px，左右10px，下20px
  * `padding: 5px 10px 20px 30px` 4个值，上5px，右10px，下20px，左30px，顺时针
* padding会影响盒子实际大小(额外撑大盒子），解决： width/height 减去多出来的内边距大小即可
* 如果盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小

#### 4、外边距(margin)

* 属性和简写同内边距

* 应用：

  * 让**块级盒子**水平居中：盒子指定宽度(width)，左右外边距设置为auto，如`.header{ width:960px; margin:0 auto;}`

* 外边距合并：使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。

  1. 相邻块元素垂直外边距的合并

     * 上下相邻的两个块元素（兄弟关系）相遇时，上面元素有下外边距，下面的元素有上外边距，则他们之间的垂直间距会被较大者合并。

     * <img src="images\image-20250323194958945.png" alt="image-20250323194958945" style="zoom:50%;" />
     * 解决：尽量只给一个盒子添加margin值

  2. 嵌套块元素垂直外边距的塌陷

     * 两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时**父元素**会塌陷**较大**的外边距值。

     * <img src="images\image-20250323195137469.png" alt="image-20250323195137469" style="zoom: 67%;" />
     * 解决：父元素定义上边框 / 父元素定义上内边距 / 父元素添加overflow:hidden / 浮动、固定、绝对定位

#### 5、清除内外边距

网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。

```css
* {
	padding:0; /* 清除内边距 */
	margin:0; /* 清除外边距 */
}
```

注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了

#### 6、盒模型(box-sizing)

* 属性值
  * `box-sizing: content-box `盒子大小为 width + padding + border （以前默认的）
  * `box-sizing: border-box` 盒子大小为 width，padding和border不会再撑大盒子（前提padding和border不会超过width宽度） 

### 8.【CSS3新增样式】

#### 1、圆角边框(border-radius)

* 语法：`border-radius: length;`
* 参数值：数值 / 百分比
* 将正方形设置成圆：将数值设为宽高的一半
* 简写：可以跟四个值：左上 | 右上 | 右下 | 左下
* 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius

#### 2、盒子阴影(box-shadow)

* 语法：`box-shadow: h-shadow v-shadow blur spread color inset;`
* 参数值说明：
  * h-shadow 必须项，水平阴影位置，可以负值
  * v-shadow 必须项，垂直阴影位置，可以负值
  * blur 模糊距离
  * spread 阴影的尺寸
  * color 阴影的颜色
  * inset 将外部阴影(outset)改为内部阴影
* 默认的是外阴影(outset), 但是**不可以**写这个单词,否则造成阴影无效
* 盒子阴影**不占用空间**，不会影响其他盒子排列。

#### 3、文字阴影

* 语法：`text-shadow: h-shadow v-shadow blur color;`
* 参数值说明：
  * h-shadow 必须项，水平阴影位置，可以负值
  * v-shadow 必须项，垂直阴影位置，可以负值
  * blur 模糊距离
  * color 阴影的颜色

### 9.【三种定位方式】

#### 1、标准流(普通流/文档流)

* 定义：标签按照默认方式排列
* 块级元素独占一行，行内元素从左到右排列

#### 2、浮动(float)

* float：创建浮动框，将其移动到一边，直到左右边缘触及包含块或另一个浮动框边缘
* 语法：`{float: 属性值;}`
* 属性值：none(默认值)不浮动，left向左浮动，right向右浮动
* 浮动特性
  * 浮动元素脱离标准流，不保留原先位置
  * 浮动元素在一行内显示并顶部对齐，贴靠在一起，装不下另起一行
  * 浮动元素具有行内块特性：大小由内容决定，中间没有缝隙
* 常用策略：使用标准流父元素来约束浮动元素，先定义盒子大小，再定义盒子位置

#### 3、清除浮动(clear)

* 原因：父级盒子不方便给高度，但子盒子在浮动情况下不占有位置，所以无法将父级盒子撑开，导致父盒子高度为0，影响下面的标准流盒子

* 本质：清楚浮动元素造成的影响，如果父盒子本身有高度则无需清除浮动

* 清除后，父级会根据浮动的子盒子自动检测高度，便不会影响下面的标准流了

* 语法：`选择器{clear: 属性值;}`

* 属性值：left清除左侧浮动，right清除右侧浮动，both同时清楚左右两侧浮动

* 清除浮动策略：闭合浮动

* 清除浮动方法：

  * 额外标签法(隔墙法)：在浮动元素末添加一个空的标签，如`\<div style="clear:both"> \</div>`，或者其他标签如br等(这个空标签一定是块级元素)

  * overflow：给父级添加overflow属性，将其设置为hidden、auto或scroll，但是无法显示溢出部分

  * :after：给父元素添加:after伪元素

    ```css
    .clearfix:after {
        content: "";
        display: block; // 插入的元素必须是块级 
        height: 0;
        clear: both;
        visibility: hidden;
    }
    .clearfix {
        /* IE6、7 专有 */
        *zoom: 1;
    }
    ```

    

  * 双伪元素：给父元素添加:before和:after双伪元素

    ```css
    .clearfix:before,.clearfix:after {
    	content:"";
    	display:table; // 转换为块级元素并且一行显示 
    }
    .clearfix:after {
    	clear:both;
    }
    .clearfix {
    	*zoom:1;
    }
    ```


#### 4、定位

* 作用：让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。
* 组成：定位 = 定位模式 + 边偏移
* 定位模式(position)：指定元素的定位方式
  * `static`静态定位：无定位(默认)
    * 语法：`选择器 { position: static; }`
    * 特点：按照标准流特性摆放位置，它没有边偏移
  * `relative`相对定位：相对原来位置定位
    * 语法：`选择器 { position: relative; }`
    * 特点：相对自己来移动，它自己原来的位置依旧占有，并且后面的盒子以标准流对待
  * `absolute`绝对定位：相对祖先元素定位
    * 语法：`选择器 { position: absolute; }`
    * 特点：
      * 如果没有**祖先元素**或者**祖先元素没有定位**，则以浏览器为准
      * 以最近一级的有定位祖先为参考
      * 不再占有原先位置(脱标)
  * `fixed`固定定位：固定于浏览器可视区的位置
    * 语法：`选择器 { position: fixed; }`
    * 特点：
      * 以浏览器的可视窗口为参照
      * 跟父元素没有关系，也不随滚动条滚动
      * 不占有原先位置
    * 固定在版心右侧位置算法：
      * 让固定定位盒子left 50%，再margin-left 版心宽度的一半
  * `sticky`粘性定位：相对定位和固定定位的混合
    * 语法：`选择器 { position: sticky; top: 10px; }`
    * 特点：
      * 以浏览器的可视窗口为参照点移动元素（固定定位特点）
      2. 粘性定位占有原先的位置（相对定位特点）
      3. 必须添加 top 、left、right、bottom 其中一个才有效
* 边偏移：决定元素的最终位置，属性为相对父元素边线的距离
  
  * `top:80px`顶端偏移量、`bottom`底部偏移量、`left`左侧偏移量、`right`右侧偏移量
* 子绝父相：子级是绝对定位，父级用相对定位。
  * 子级不占有位置，放在父级任何位置，不影响兄弟盒子
  * 父级加定位限制子盒子位置
  * 父级布局时必须也使用定位，不加定位子级会乱跑，故在四种定位中优先使用相对定位
* 定位叠放次序(z-index)：控制盒子的前后次序
  * 语法：选择器 `{ z-index: 1;} ` 
  * 特点
    * 数值可以是正整数、负整数或 0, 默认是 auto，数值越大，盒子越靠上
    * 如果属性值相同，则按照书写顺序，后来居上
    * 数字后面不能加单位
    * 只有定位的盒子才有 z-index 属性
* 绝对定位盒子居中算法
  * 无法通过`margin:0 auto`水平居中
  * 先 left: 50%，再margin-left: 盒子左移自身宽度一半(通常为负值)
* 定位特殊特性：
  * **行内元素**添加绝对或者固定定位，可以直接设置高度和宽度。(原本无法给宽高)
  * **块级元素**添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。(原本是占据一整行)
* 脱标的盒子不会触发外边距塌陷：浮动元素、绝对定位(固定定位)元素的都不会触发外边距合并的问题。
* 绝对定位（固定定位）会完全压住盒子：
  * 浮动元素会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）
  * 绝对定位（固定定位） 会压住下面标准流所有的内容。

### 10.【属性书写顺序】

建议遵循以下顺序：

1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word
4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …

### 11.【元素显示与隐藏】

#### 1、显示隐藏(display)

* display：设置一个元素应如何显示。
* 属性：`display: none `隐藏对象；`display：block`转换为块级元素并显示元素
* 特点：display 隐藏元素后，**不再占有原来的位置**。

#### 2、显示隐藏(visibility)

* visibility：指定一个元素应可见还是隐藏。
* 属性：`visibility：visible`元素可视；`visibility：hidden`元素隐藏
* 特点：visibility 隐藏元素后，**继续占有原来的位置**。

#### 3、溢出显示隐藏(overflow)

* overflow ：对溢出元素的部分进行操作
* 属性
  * `visible`不剪切内容也不添加滚动条
  * `hidden`不显示超过对象尺寸的内容，超出的部分隐藏掉
  * `scroll`不管是否超出，总是显示滚动条
  * `auto`超出自动显示滚动条，不超出不显示滚动条

### 12.【CSS用户界面样式】

* 界面样式：更改用户操作样式，提高用户体验(如：更改鼠标样式、表单轮廓、防止表单拖拽等)

#### 1、鼠标样式(cursor)

* 语法：`li { cursor: pointer; }`
* 属性值：`default(默认)`小白、`pointer`小手、`move`移动、`text`文本、`not-allowed`禁止

#### 2、轮廓线(outline)

* 语法：`input {outline: none; }`
* 表单添加 outline: 0; 或 outline: none; 样式之后，就可以去掉默认的蓝色边框。

#### 3、防止拖拽文本域(resize)

* 语法：`textarea{ resize: none;}`

### 13.【其他】

#### 1、精灵图

* 原理：将网页中的一些小背景图像整合到一张大图中 ，服务器只需要一次请求就可以获得全部，提高页面加载速度
* 使用：
  * 将多个小背景整合到一张大图片(sprites 精灵图)中
  * 创建一个盒子，放入精灵图并移动它(background-position)
  * 向上和向左移动为负值，向下和向右为正值
  * 将精灵图通过坐标移动到所需要的图像位置，盒子只显示所需的图标，从而获得该小图标

#### 2、CSS三角

原理：当一个盒子没有宽高，只给它加一定的边框时，且边框的四边颜色都不同时，会有以下效果：

所以，当其中三边都为透明色时，即可获得一个三角形

![image-20250402210512370](images\image-20250402210512370.png)

```css
div {
	width: 0;
	height: 0;
	line-height: 0;
	font-size: 0;
	border: 50px solid transparent;
	border-left-color: pink;
}
```

#### 3、字体图标(iconfont)

1. 字体图标的下载

   * icomoon 字库 http://icomoon.io 
   * 阿里 iconfont 字库 http://www.iconfont.cn/

2. 字体图标的引入

   * 将下载包中的fonts文件夹 放入页面根目录下

   * 在CSS中全局声明字体(引入页面)

   * ```css
     @font-face {
     	font-family: 'icomoon';
     	src: url('fonts/icomoon.eot?7kkyc2');
     	src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
     	url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
     	url('fonts/icomoon.woff?7kkyc2') format('woff'),
     	url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
     	font-weight: normal;
     	font-style: normal;
     }
     ```

   * 在html标签内添加小图标 ` <span> </span>`

   * 给标签定义字体 `span { font-family: "icomoon"; }`(必须与引入@font-face里面的字体名字一致)

3. 字体图标的追加：将下载包里的selection.json重新上传到网页，然后选中新的图标，下载新压缩包并替换原来文件

#### 4、元素对齐方式(vertical-align)

* 使用场景：设置图片或表单和文字的对齐方式，只对行内元素或行内块元素有效
* 语法：`vertical-align : baseline(默认)基线对齐 | top顶端对齐 | middle中间对齐 | bottom底部对齐 `
* 解决图片底部默认有空白缝隙：
  * 原因：行内块元素是和文字的基线对齐
  * 解决
    1. 给图片添加` vertical-align:middle | top| bottom`
    2. 把图片转换为块级元素`display: block;`

#### 5、溢出文字省略号显示

1. 单行文本溢出：

   ```CSS
   /*1. 先强制一行内显示文本*/
    white-space: nowrap; （ 默认 normal 自动换行）
    /*2. 超出的部分隐藏*/
    overflow: hidden;
    /*3. 文字用省略号替代超出的部分*/
    text-overflow: ellipsis;
   ```

2. 多行文本溢出：

   ```css
   overflow: hidden;
   text-overflow: ellipsis;
   /* 弹性伸缩盒子模型显示 */
   display: -webkit-box;
   /* 限制在一个块元素显示的文本的行数 */
   -webkit-line-clamp: 2;
   /* 设置或检索伸缩盒对象的子元素的排列方式 */
   -webkit-box-orient: vertical;
   ```

#### 6、布局技巧

1. margin负值的运用 

   <img src="images\image-20250403131125481.png" alt="image-20250403131125481" style="zoom:67%;" />

   1. 让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 
   2. 鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index）

2. 文字围绕浮动元素

   ![image-20250403131218451](images\image-20250403131218451.png)

   将图片浮动，调节外边距

3. 行内块的巧妙运用

   ![image-20250403131256243](images\image-20250403131256243.png)

   页码在页面中间显示: 

   1. 把这些链接盒子转换为行内块，之后给父级指定 text-align:center; 
   2. 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中

4. CSS三角强化

   ![image-20250403131330130](images\image-20250403131330130.png)

   ```css
   width: 0;
   height: 0;
   border-color: transparent red transparent transparent;
   border-style: solid;
   border-width: 22px 8px 0 0;
   ```

#### 7、css初始化

* 定义：CSS初始化是指重设浏览器的样式。 (也称为CSS reset）

#### 8、滤镜(filter)

* 定义：filter：将模糊或颜色偏移等图形效果应用于元素。 

* 语法：`filter: 函数(); ` 

* ```css
  e { filter: blur(5px); }   // blur模糊处理  数值越大越模糊
  ```

#### 9、calc 函数

* 定义：在声明CSS属性值时执行一些计算
* `width: calc(100% - 80px); `
* 括号里面可以使用 + - *  / 来进行计算。 

#### 10、浏览器私有前缀

1. 私有前缀

   * -moz-：代表 firefox 浏览器私有属性
   * -ms-：代表 ie 浏览器私有属性
   * -webkit-：代表 safari、chrome 私有属性
   * -o-：代表 Opera 私有属性

2. 提倡的写法

   ```css
   -moz-border-radius: 10px;
   -webkit-border-radius: 10px;
   -o-border-radius: 10px;
   border-radius: 10px;
   ```

   

### 14.【CSS3 过渡(transition)】

* 语法：` transition: 要过渡的属性  花费时间  运动曲线  何时开始; `
* 属性：想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以。 
* 花费时间： 单位是 秒（必须写单位） 比如 0.5s  
* 运动曲线： 默认是 ease （可以省略） 
* 何时开始 ：单位是 秒（必须写单位）可以设置延迟触发时间  默认是 0s  （可以省略）
* ![06-HTML5 和 CSS3 的新特性04](images\06-HTML5 和 CSS3 的新特性04.png)
* 经常和 :hover 一起 搭配使用。

### 15.【CSS3 2D转换】

#### 1、移动(translate)

* 语法：

  ```css
  transform: translate(x,y); 或者分开写
  transform: translateX(n);
  transform: translateY(n);
  ```

* 定义 2D 转换中的移动，沿着 X 和 Y 轴移动元素

* translate**不会影响**到其他元素的位置

* translate中的百分比单位是**相对于自身元素**的 translate:(50%,50%);

* 对**行内标签**没有效果

#### 2、旋转(rotate)

* 语法：`transfrom: rotate(度数)`
* rotate单位为**度数**， 单位是 deg 如 `rotate(45deg)` 
* 角度为正时，顺时针；负时，为逆时针
* 默认旋转的中心点是元素的中心点

#### 3、转换中心点(transform-origin)

* 语法：`transform-origin: x y;`
* 注意后面的参数 x 和 y 用空格隔开
* x y 默认转换的中心点是元素的中心点 (50% 50%) 
* 还可以给x y 设置 像素 或者 方位名词 （top bottom left right center）

#### 4、缩放(scale)

* 语法：`transform:scale(x,y);`
* 参数中的 x 和 y 用逗号分隔
* transform:scale(1,1) ：宽和高都放大一倍，相对于没有放大
* transform:scale(2,2) ：宽和高都放大了2倍
* transform:scale(2) ：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2) 
* transform:scale(0.5,0.5)：缩小
* sacle缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子

#### 5、综合写法

* 语法：`transform: translate() rotate() scale() ...`
* 其顺序会影响转换的效果。（先旋转会改变坐标轴方向）
* 同时有位移和其他属性的时候，**位移**放到最前

### 16.【CSS3 动画(animation)】

#### 1、定义动画(keyframes)

* 语法

  ```css
  @keyframes 动画名称 {
  	0%{
  		width:100px;
  	}
  	100%{
  		width:200px;
  	}
  }
  ```

* 动画序列

  * 0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。
  * 在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。
  * 动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数。
  * 用百分比来规定变化发生的时间，或用关键词 "from" 和 "to"，等同于 0% 和 100%。

#### 2、使用动画(animation)

* 语法

  ```css
  div {
  	width: 200px;
  	height: 200px;
  	background-color: aqua;
  	margin: 100px auto;
  	/* 调用动画 */
  	animation-name: 动画名称;
  	/* 持续时间 */
  	animation-duration: 持续时间;
  }
  ```

* 动画常见属性

  |           属性            | 描述                                                         |
  | :-----------------------: | :----------------------------------------------------------- |
  |        @keyframes         | 规定动画。                                                   |
  |         animation         | 所有动画属性的简写属性，除了animation-play-state属性。       |
  |      animation-name       | 规定@keyframes动画的名称。（必须的）                         |
  |    animation-duration     | 规定动画完成一个周期所花费的秒或毫秒，默认是0。（必须的）    |
  | animation-timing-function | 规定动画的速度曲线，默认是“ease”。                           |
  |      animation-delay      | 规定动画何时开始，默认是0。                                  |
  | animation-iteration-count | 规定动画被播放的次数，默认是1，还有infinite                  |
  |    animation-direction    | 规定动画是否在下一周期逆向播放，默认是“normal“,alternate逆播放 |
  |   animation-play-state    | 规定动画是否正在运行或暂停。默认是"running",还有"paused"。   |
  |    animation-fill-mode    | 规定动画结束后状态，保持forwards回到起始backwards            |

* 动画简写属性

  * animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;
  * `animation: myfirst 5s linear 2s infinite alternate;`
  * 简写属性里面不包含 animation-play-state

* 注意点

  * 暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用
  * 想要动画走回来 ，而不是直接跳回来：animation-direction: alternate
  * 盒子动画结束后，停在结束位置：  animation-fill-mode: forwards

* 速度曲线

  * animation-timing-function：规定动画的速度曲线，默认是“ease”

    |     值      | 描述                                           |
    | :---------: | ---------------------------------------------- |
    |   linear    | 动画从头到尾的速度是相同的。匀速               |
    |    ease     | 默认。动画以低速开始，然后加快，在结束前变慢。 |
    |   ease-in   | 动画以低速开始。                               |
    |  ease-out   | 动画以低速结束。                               |
    | ease-in-out | 动画以低速开始和结束。                         |
    |   steps()   | 指定了时间函数中的间隔数量（步长）             |

### 17.【CSS3 3D转换】

#### 1、3D移动(translate3d)

* transform:translateX(100px)：仅仅是在x轴上移动
* transform:translateY(100px)：仅仅是在Y轴上移动
* transform:translateZ(100px)：仅仅是在Z轴上移动（注意：translateZ一般用px单位）
* transform:translate3d(x,y,z)：其中 x、y、z 分别指要移动的轴的方向的距离
* 因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动

#### 2、透视(perspective)

* 语法：`perspective: 像素`

* 透视让网页产生3D效果
* 透视也称为视距：视距就是人的眼睛到屏幕的距离
* 距离 视觉点 越近成像越大，越远成像越小
* 透视的单位是像素
* 透视写在被观察元素的父盒子上

#### 3、3D旋转(rotate3d)

* 语法
  * transform:rotateX(45deg)：沿着x轴正方向旋转 45度
  * transform:rotateY(45deg) ：沿着y轴正方向旋转 45deg
  * transform:rotateZ(45deg) ：沿着Z轴正方向旋转 45deg
  * transform:rotate3d(x,y,z,deg)： 沿着自定义轴旋转 deg为角度（了解即可）
    * ransform:rotate3d(1,0,0,45deg) 就是沿着x轴旋转 45deg
    * ransform:rotate3d(1,1,0,45deg) 就是沿着对角线旋转 45deg
* 左手准则：左手拇指指向的为轴，四指弯曲的方向为该轴的旋转正方向

#### 4、3D呈现(transfrom-style)

* 作用：控制子元素是否开启三维立体环境
* 属性：`transform-style: flat(默认)子元素不开启3d立体空间 / preserve-3d(子元素开启立体空间)`
* 代码写给父级，但是影响的是子盒子







# JS

### JavaScript介绍

#### 书写位置

##### 1、内部JavaScript

* 直接写在html文件里，用script标签包住
* 规范：将script标签写载HTML页面底部(\</body>上面)
* 原因：浏览器会按顺序加载代码，若先加载JavaScript，那么可能会由于HTML尚未被加载而失效，因此将JavaScript代码放在HTML页面底部附近是最好的策略

##### 2、外部JavaScript

* 写在以.js结尾的文件里
* 通过 `<script src="my.js></script>"` 引入html页面中
* 注意：script标签中间无需写代码，否则会被忽略！

##### 3、内联JavaScript

* 写在标签内部
* 语法：`<button onclick="alert('是wsy！')">努力学前端的是谁呀</button>`

#### 结束符

* 分号 ；
* 可写可不写，但要么全写要么全不写，根据团队统一

#### 输入输出语法

##### 1、输出语法

1. 语法1
   * `document.write('要输出的内容')`
   * 作用：向body内输出内容
   * 注意：如果输出的内容写的是标签，也会被解析成网页元素
2.  语法2
   * `alert('警告你喔')`
   * 作用：页面弹出警告对话框
3. 语法3
   * `console.log('控制台打印')`
   * 作用：控制台输出语法，程序员调试使用

##### 2、输入语法

* `prompt('请输入您的姓名')`
* 作用：显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字
* <img src="\images\js\1.png" alt="1" style="zoom:67%;" />

### 基础语法

#### 变量

* 声明：`let 变量名`
  * 可以一行声明多个变量，但更推荐一行声明一个
* 命名规则：
  * 关键字：let、var等
  * 可以用下划线、字母、数字、$组成，但数字不能开头
  * 严格区分大小写
  * 命名遵守小驼峰命名法

* let 和 var 区别： var是旧版js使用的，let是var的修复版，故统一使用let即可
* 数组：`let 数组名 = [数据1，数据2，...，数据n]`
  * 数据可以存储任意类型的数据
  * 数据名.length：数组长度

#### 常量

* 声明：`const 变量 = 值`
  * 不可重新赋值，必须初始化

#### 数据类型

* 数据类型
  * 基本数据类型：number | string | boolean | undefined(未定义型) | null
  * 引用数据类型：object
  * JS 是弱数据类型，同py相似
* 数据类型介绍
  * NaN：代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。任何对 NaN 的操作都会返回 NaN 
  * String：推荐使用单引号包裹
    * 模板字符串：用反引号引起来的字符串，可以在内容里用${}来包住变量
    * ``document.write(`大家好，我叫${name}，今年${age}岁`)``
  * undefined：只声明未赋值的变量
    * undefined 和 null 区别：undefined表示未赋值，null表示赋值了但内容为空
* 检测数据类型
  * typeof关键字检查
  * 语法
    * 作为运算符：`typeof x`(常用写法)
    * 作为函数：`typeof(x)`

#### 类型转换

* 原因：表单、prompt获取的数据默认是字符串类型
* 隐式转换
  * \+ 号两边只要有一个是字符串，都会把另外一个转成字符串
  * 除了+以外的算术运算符 比如 -  *  /  等都会把数据转成数字类型
  * `let x = +字符串` 这种写法可以让字符串转换成数字型，但若该字符串不是数字会产生NaN
* 显示转换
  * 数字型
    * Number(数据)：若有非数字，会转换失败，结果为NaN
    * parseInt(数据)
    * parseFloat(数据)
  * 字符型
    * String(数据)
    * 变量.toString(进制)

#### 运算符

* 比较运算符
  * ==：左右值是否相等
  * ===：左右值以及类型是否都相等(全等)
  * !==：左右两边是否不全等
  * 不同类型之间比较会发生隐式转换，故使用===会更好

#### 数组

##### 1、添加新的数据

* 数组.push( )：将一个或多个元素添加到数组的**末尾**，并返回该数组的新长度
* 语法：`arr.push(元素1,...,元素n)`
* arr.unshift( )：将一个或多个元素添加到数组的**开头**，并返回该数组的新长度

##### 2、删除数组中的数据

* 数组.pop( )：从数组中删除最后一个元素，并返回该元素的值
* 数组.shift( )：从数组中删除第一个元素，并返回该元素的值
* 数组.splice( )：删除指定元素
* 语法：`arr.splice(start,count)` count可选，省略则默认从start删到最后

##### 3、数组排序

* 数组.sort() 

* ```js
  let arr = [4, 2, 5, 1, 3]
  // 1.升序排列写法
  arr.sort(function (a, b) {
  	return a - b
  })
  console.log(arr)  // [1, 2, 3, 4, 5]
  // 降序排列写法
  arr.sort(function (a, b) {
  	return b - a
  })
  console.log(arr)  // [5, 4, 3, 2, 1]
  ```

##### 4、数组中map方法

* map()：迭代数组

* 语法：

  ```js
  const arr = ['pink','red','blue']
  arr.map(function(){
      // 方法体，会依次遍历数组的每一个数据
  })
  ```

##### 5、数组中join方法

* join() 方法用于把数组中的所有元素转换一个字符串

* 语法：

  ```js
  const arr = ['pink','red','blue']
  let str = arr.join(' ') // pink red blue
  ```

* 参数：数组元素是通过参数里面指定的分隔符进行分隔的，默认为逗号

##### 6、遍历数组forEach方法

forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数

```js
数组.forEach(function(当前数组元素，当前元素索引号){
    // 函数体
})
```

##### 7、筛选数组filter方法

 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素

```js
数组.filter(function(currentValue, index){
    return 筛选条件
})
```

* 参数：currentValue 必须写， index 可选
* 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组

#### 函数

* 声明：

  ```js
  function 函数名(参数列表) {
      函数体
      retrun 数据
  }
  ```

* 命名

  * 小驼峰命名法
  * 前缀应该为动词

* 参数默认值

  * ``` js
    function getSum(x = 0, y = 0){
        document.write(x + y)
    }
    getSum() // 结果是0，而不是NaN
    getSum(1，2) // 3
    ```

  * 如果没有默认值，在调用的时候用户没有输入实参，那么可能会返回NaN，故这种写法可以让其返回0，更加严谨

* 逻辑中断

  * ```js
    x = x || 0 // 如果x没有赋值，则可以用0赋值给x
    var dpr = window.devicePixelRatio || 1 // 获取当前设备，若获取不到则默认取值1
    ```

#### 对象

* 声明

  * `let 对象名 = {} ` // {}是对象字面量，常用
  * `let 对象名 = new Object()`

* 使用

  ```js
  let 对象名 = {
      属性名: 属性值,
      方法名: 函数
  }
  如：
  let obj = {
      uname: 'wsy',
      age: 18,
      now: '学前端'
  }
  ```

* 属性增加：`对象名.新属性 = 新值`

* 属性删减：`delete 对象名.属性`

* 属性查找

  ```js
  let person = {
      'user-name': 'wsy',
      age: 18,
      now: '学前端'
  }
  console.log(person.user-name) // NaN
  console.log(person['user-name']) // wsy
  ```

  * `对象[‘属性’]`  方式， 单引号和双引号都可以
  * [ ]语法里面的值如果不添加引号 默认会当成变量解析

* 对象中的方法

  ```js
  let person = {
      name: 'wsy',
      sayHi: function() {
          document.write('你好呀~')
      }
  }
  person.sayHi()
  ```

* 遍历对象

  ```js
  let person = {
      name: 'wsy',
      age: 18,
      now: '学前端'
  }
  for (let k in person) {
      console.log(k) // 打印属性名
      console.log(obj[k]) // 打印属性值
  }
  ```

  * 由于k是一个变量，故必须使用[ ]语法来解析

* 内置对象
  * Math：https://www.w3school.com.cn/jsref/jsref_obj_math.asp
    *  Math.random()  随机数函数， 返回一个0 - 1之间，并且包括0不包括1的随机小数  [0, 1）
    * 生成0-10的随机数：`Math.floor(Math.random() * (10 + 1))`
    * 生成N-M之间的随机数：`Math.floor(Math.random() * (M - N + 1)) + N`

### DOM

#### DOM定义

##### 1、DOM

DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API (浏览器提供的一套专门用来**操作网页内容**的功能)

##### 2、DOM树

将HTML文档以树状结构直观的表现出来，该结构称为文档树或DOM树

##### 3、DOM对象

浏览器根据html标签生成的JS对象，其核心即把内容当对象处理

* document对象：DOM提供的一个对象，用来访问和操作网页内容
* 网页所有内容都在document里面

#### 获取DOM对象

##### 1、根据CSS选择器获取DOM元素

1. 选择匹配的第一个元素
   * 语法：`document.querySelector('css选择器')`
   * 返回值：CSS选择器匹配的第一个元素,一个 HTMLElement对象。如果没有匹配到，则返回null。
2. 选择匹配的多个元素
   * 语法：`document.querySelectorAll('css选择器')`
   * 返回值：CSS选择器匹配的 NodeList 对象集合
   * 该对象是一个伪数组，有长度索引但没有pop、push等方法；只能通过遍历得到每个元素
   * 注意：哪怕只有一个元素，通过querySelectAll() 获取过来的也是一个伪数组，里面只有一个元素而已

##### 2、其他获取DOM元素方法

```js
document.getElementById('nav') // 根据id获取一个元素
document.getElementsByTagName('div') // 根据标签获取一类元素
document.getElementsByClassName('w') // 根据类名获取元素
```

#### 操作DOM对象元素

##### 1、操作元素内容

1. 元素.innerText  属性
   * 将文本内容添加/修改到任意标签位置
   * 显示纯文本，**不解析标签**

2. 元素.innerHTML  属性
   * 将文本内容添加/更新到任意标签位置
   * **会解析标签**，多标签建议使用**模板字符串**

##### 2、操作元素属性

1. 操作元素常用属性(html标签属性)

   	* 通过js 设置/修改标签元素属性
      	* 语法：`对象.属性 = 值`

2. 操作元素样式属性(标签的css属性)

   * 修改标签元素的样式属性，如修改颜色样式、移动图片位置

   1. 通过style属性操作CSS：`对象.style.样式属性 = 值`

      * 修改样式通过style属性引出
      * 如果属性有-连接符，需要转换为小驼峰命名法
      * 赋值的时候，需要的时候不要忘记加css单位

   2. 操作类名(className)操作CSS：`元素.className = 'active'`

      * 由于class是关键字, 所以使用className去代替
      * className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名

   3. 通过classList操作类控制CSS

      ```js
      元素.classList.add('类名') // 追加一个类
      元素.classList.remove('类名') // 删除一个类
      元素.classList.toggle('类名') // 切换一个类
      ```

3. 操作表单元素属性

    1. 设置表单元素属性：`DOM对象.属性名`，如：`表单元素.value = '用户名'`

    2.  表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示

        * 设置为true 代表添加该属性，设置为false 代表移除了该属性

        * 如：disabled、checked、selected

4. 自定义属性

    1. 在html5中推出来了专门的data-自定义属性
    2. 在标签上一律以`data-`开头
    3. 在DOM对象上一律以 dataset对象 方式获取
        1. 设置：`<div class="box" data-id="10"></div>`
        2. 获取：`console.log(box.dataset.id)`

#### 定时器--间歇函数

* 开启定时器
  * 语法：`setInterval(函数名, 间隔时间)`
  * 作用：每隔一段时间调用这个函数，间隔时间单位是毫秒ms
  * 注意：函数名不需要加括号；定时器返回值为id数字
* 关闭定时器
  * 语法：`clearInterval(定时器返回值)`
  * 如果需要再次开启定时器，则需要重新调用`setInterval(函数名, 间隔时间)`，同时该返回值会更新，故保存返回值需要用let

### DOM事件基础

#### 事件监听(绑定)

* 语法：`元素对象.addEventListener('事件类型',要执行的函数)`
* 事件监听三要素：
  * 事件源： 那个dom元素被事件触发了，要获取dom元素 
  * 事件类型： 用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等
  * 事件调用的函数： 要做什么事
* 注意：事件类型要加引号
* 事件监听版本：
  * DOM L0 
         事件源.on事件 = function() { }
  * DOM L2 
         事件源.addEventListener(事件， 事件处理函数)
  * 区别：
         on方式会被覆盖，addEventListener方式可绑定多次，拥有事件更多特性，推荐使用

#### 事件类型

* 鼠标事件
  * click 鼠标点击
  * mouseenter 鼠标经过
  * mouseleave 鼠标离开
* 表单获得光标
  * focus 获得焦点
  * blur 失去焦点
* 键盘触发
  * Keydown 键盘按下触发
  * Keyup 键盘抬起触发
* 表单输入触发
  * input 用户输入事件

#### 事件对象

* 获得事件对象

  * 回调函数的第一个参数就是事件对象，一般命名为event、ev、e

  * 语法

    ```js
    元素.addEventListener('click', function(e){ // e则为事件对象
        
    })
    ```

* 事件对象常用属性

  * type 获取当前事件类型
  * clientX/clientY 获取光标相对于浏览器可见窗口左上角的位置
  * offsetX/offsetY 获得光标相对于当前DOM元素左上角的位置
  * key 用户按下的键盘键的值，不提倡使用keyCode

#### 环境对象

* 环境对象：指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境
* 直接调用函数，其实相当于是 window.函数，所以 this 指代 window

#### 回调函数

当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数

### DOM事件进阶

#### 事件流

##### 1、事件流的两个阶段

* 事件流：指的是事件完整执行过程中的流动路径
* 两个阶段
  * 捕获阶段：从父级到子级
  * 冒泡阶段：从子级到父级

##### 2、事件捕获

* 概念：从DOM的根元素开始去执行对应的事件 (从外到里)
* 语法：`DOM.addEventListener(事件类型,事件处理函数,是否使用捕获机制)`
* 说明
  * addEventListener第三个参数传入 true 代表是捕获阶段触发（很少使用）
  * 若传入false代表冒泡阶段触发，默认就是false
  * 若是用 L0 事件监听，则只有冒泡阶段，没有捕获

##### 3、事件冒泡

* 概念：当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡
* L2事件监听第三个参数是 false，或者默认都是冒泡（故事件冒泡是默认存在的）

##### 4、阻止冒泡

* 原因：冒泡模式容易影响到父级元素，通过阻止冒泡来阻止事件冒泡

* 阻止冒泡语法：`事件对象.stopPropagation()`（此方法可以阻断事件流动传播，捕获阶段也有效）

* 阻止默认行为发生：`e.preventDefault()`

  ```js
  元素.addEventListener('click', function(e){
      e.preventDefault()
  })
  ```

##### 5、解绑事件

* L0事件解绑：

  ```js
  btn.onclick = function(){
      alert('点击')
  }
  btn.onclick = null // 解绑（类似于赋值操作）
  ```

* L2事件监听解绑：`removeEventListener(事件类型, 事件处理函数,  [获取捕获或者冒泡阶段])`

  ```js
  function fu(){
      alert('点击')
  }
  btn.addEventListener('click',fn) // 绑定事件
  btn.removeEventListener('click',fn) // 解绑事件
  ```

##### 6、鼠标经过事件区别

* mouseover 和 mouseout 会有冒泡效果
* mouseenter 和 mouseleave 没有冒泡效果

##### 7、两种注册事件区别

* 传统on注册(L0)
  * 同一个对象,后面注册的事件会覆盖前面注册(同一个事件)
  * 直接使用null覆盖偶就可以实现事件的解绑
  * 都是冒泡阶段执行的
* 事件监听注册（L2）
  * 语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获)
  * 后面注册的事件不会覆盖前面注册的事件(同一个事件)
  * 可以通过第三个参数去确定是在冒泡或者捕获阶段执行
  * 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)
  * 匿名函数无法被解绑

#### 事件委托

* 原理：利用事件冒泡的特点，给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件

* 实现：事件对象.target. tagName 可以获得真正触发事件的元素

* 如

  ```js
  const ul = document.querySelector('ul')
  ul.addEventListener('click',function(e){
      if (e.target.tagName === 'LI'){ // 可以先F12检查看tagName是什么
          this.style.color = 'pink'
      }
  })
  ```

#### 其他事件

##### 1、页面加载事件

* **load事件**

  * 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件

  * 监听页面所有资源加载完毕：给window添加load事件

  * ```js
    // 页面加载事件
    window.addEventListener('load',function(){
        // 执行的操作
    })
    ```

  * 不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件

* **DOMContentLoaded事件**

  * 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载

  * 监听页面DOM加载完毕：给document添加 DOMContentLoaded 事件

  * ```js
    document.addEventListener('DOMContentLoaded',function(){
        // 执行的操作
    })
    ```

##### 2、元素滚动事件

* **scroll事件**

  * 滚动条在滚动的时候持续触发的事件

  * 监听整个页面滚动：给 window 或 document 添加 scroll 事件

  * ```js
    window.addEventListener('scroll',function(){
        // 执行的操作
    })
    ```

  * 监听某个元素的内部滚动直接给某个元素加即可

* 获取位置

  * scrollLeft和scrollTop （属性）

    * 获取被卷去的大小
    * 获取元素内容往左、往上滚出去看不到的距离
    * 这两个值是可读写的（可直接赋值）

  * 尽量在scroll事件里面获取被卷去的距离

  * 检测页面滚动的距离：

  * ```js
    window.addEventListener('scroll',function(){
        let n = document.documentElement.scrollTop
    })
    ```

  * document.documentElement   HTML 文档返回对象为HTML元素

##### 3、页面尺寸事件

* resize事件

  * 会在窗口尺寸改变的时候触发事件

  * 检测屏幕宽度：

  * ```js
    window.addEventListener('resize',function(){
        let w = document.documentElement.clientWidth
    })
    ```

* 获取元素宽高

  * 获取元素的可见部分宽高（不包含边框，margin，滚动条等）
  * clientWidth和clientHeight

#### 元素尺寸与位置

##### 1、尺寸

* 获取元素宽高

  * offsetWidth和offsetHeight (只读属性)
  * 元素的自身宽高、包含元素自身设置的宽高、padding、border
  * 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0

* 获取元素位置

  1. offsetLeft和offsetTop
     * 只读属性
     * 获取元素距离自己定位父级元素的左、上距离

  2. element.getBoundingClientRect()
     * 返回元素的大小及其相对于视口的位置

### DOM节点

#### 日期对象

##### 1、实例化

* 获得当前时间：`const date = new Date()`
* 获得指定时间：`const date = new Date('2008-8-8')`

##### 2、日期对象方法

| 方法          | 作用               | 说明                 |
| ------------- | ------------------ | -------------------- |
| getFullYear() | 获得年份           | 获取四位年份         |
| getMonth()    | 获得月份           | 取值为 0 ~ 11        |
| getDate()     | 获取月份中的每一天 | 不同月份取值也不相同 |
| getDay()      | 获取星期           | 取值为 0 ~ 6         |
| getHours()    | 获取小时           | 取值为 0 ~ 23        |
| getMinutes()  | 获取分钟           | 取值为 0 ~ 59        |
| getSeconds()  | 获取秒             | 取值为 0 ~ 59        |

##### 3、时间戳

获得时间戳的三种方式

* 使用getTime()方法

  ```js
  const date = new Date()
  console.log(date.getTime())
  ```

* 简写 + new Date()：`console.log(+new Date())`(因为new Date() 得到的是一串字符串，故使用+将其转换成整型)

* 使用Date.now()：`console.log(Date.now())`( 但是只能得到当前的时间戳， 而前面两种可以返回指定时间的时间戳)

#### 节点操作

##### 1、DOM节点

* DOM节点： DOM树里每一个内容都称之为节点
* 节点类型：
  * 元素节点：所有的标签 比如 body、 div；html 是根节点
  * 属性节点：所有的属性 比如 href
  * 文本节点：所有的文本 
  * 其他

##### 2、查找节点

* 查找父节点：`子元素.parentNode`（返回最近一级的父节点 找不到返回为null）
* 查找子节点：`父元素.children`
  * 获得所有子节点、包括文本节点（空格、换行）、注释节点等
  * 返回的还是一个伪数组
* 查找兄弟节点：
  * 查找下一个兄弟节点：`元素.nextElementSibling`
  * 查找上一个兄弟节点：`元素.previousElementSibling`

##### 3、增加节点

* 创建节点：`document.createElement('标签名')`
* 追加节点：
  * 插入到父元素的最后一个子元素：`父元素.appendChild(要插入的元素)`
  * 插入到父元素中某个子元素的前面：`父元素.insertBefore(要插入的元素，在哪个元素前面)`
* 克隆节点：`元素.cloneNode(布尔值)`
  * 若为true，则代表克隆时会包含后代节点一起克隆(深克隆)
  * 若为false，则代表克隆时不包含后代节点，默认为false(浅克隆)

##### 4、删除节点

* 必须通过父元素删除：`父元素.removeChild(要删除的元素)`
  * 如不存在父子关系则删除不成功
  * 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点

#### M端事件

* M端即移动端
* 触屏事件touch：
  * touchstart：手指触摸到一个DOM元素时触发
  * touchmove：在DOM元素上滑动时触发
  * touchend：在DOM元素上移开时触发

#### JS插件

* 官网： https://www.swiper.com.cn/ 

### BOM操作

#### Window对象

##### 1、BOM

* BOM：浏览器对象模型
* window对象是一个全局对象，也可以说是JavaScript中的顶级对象
* 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。
* 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法
* window对象下的属性和方法调用的时候可以省略window

##### 2、定时器——延迟函数

* 语法：`setTimeout(回调函数，等待的毫秒数)`(setTimeout 仅仅只执行一次)

* 清除延时函数

  ```js
  let timer = setTimeout()
  clearTimeout(timer)
  ```

* 延时器需要等待,所以后面的代码先执行

* 每一次调用延时器都会产生一个新的延时器

##### 3、JS执行机制

* 同步任务：同步任务都在主线程上执行，形成一个执行栈。

* 异步任务：通过回调函数实现的，异步任务有三种类型

  * 普通事件，如 click、resize 等
  * 资源加载，如 load、error 等
  * 定时器，包括 setInterval、setTimeout 等

  异步任务相关添加到任务队列中（任务队列也称为消息队列）。

* 执行顺序：

  * 先执行执行栈中的同步任务。
  * 异步任务放入任务队列中。
  *  一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
  * ![2](images\js\2.png)
  * 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop )

##### 4、location对象

* location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分

* 常用属性：
  * href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转
  * search 属性获取地址中携带的参数，符号 ？后面部分
  * hash 属性获取地址中的啥希值，符号 # 后面部分
  * reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新
* 语法：`location.属性`

##### 5、navigator对象

* navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

* 常用属性

  * 通过 userAgent 检测浏览器的版本及平台

  * ```js
    // 检测 userAgent（浏览器信息）
    !(function () {
    	const userAgent = navigator.userAgent
    	// 验证是否为Android或iPhone
    	const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/)
    	const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
    	// 如果是Android或iPhone，则跳转至移动站点
    	if (android || iphone) {
    		location.href = 'http://m.itcast.cn'
    	}
    })()
    ```

* 语法：`navigator.属性`

##### 6、histroy对象

* history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等
* 常用方法
  * back()  后退
  * forward()  前进
  * go(参数)  参数为1：前进，参数为-1：后退

#### 本地存储

##### 1、localStorage

* 作用：可以将数据永久存储在本地(用户的电脑), 除非手动删除，否则关闭页面也会存在
* 特性：
  * 可以多窗口（页面）共享（同一浏览器可以共享）
  * 以键值对的形式存储使用
* 语法：
  * 存储数据：`localStorage.setItem(key, value)`
  * 获取数据：`localStorage.getItem(key)`
  * 删除数据：`localStorage.removeItem(key)`

##### 2、sessionStorage

* 特性：
  * 生命周期为关闭浏览器窗口(同一个会话里)
  * 在同一个窗口(页面)下数据可以共享
  * 以键值对的形式存储使用
  * 用法跟localStorage 基本相同

##### 3、存储复杂数据类型

* 将复杂数据类型转换成JSON字符串,在存储到本地
  * 语法：`JSON.stringify(复杂数据类型)`
* 把取出来的字符串转换为对象
  * 语法：`JSON.parse(JSON字符串)`

### 正则表达式

##### 1、语法

* 定义正则表达式：`const 变量 = /表达式/`
* 判断是否有符合规则的字符串：test() 方法   查看正则表达式与指定的字符串是否匹配
  * `regObj.test(被检测字符串)` // 匹配为true，不匹配false
* 检索（查找）符合规则的字符串：exec() 方法 在一个指定字符串中执行一个搜索匹配
  * `regObj.exec(被检测字符串)` // 匹配返回一个数组，否则返回null

##### 2、元字符

* 边界符：提示字符所处的位置

  * ^     匹配行首的文本(以谁开始)
  * $     匹配行尾的文本(以谁结束)
  * 如果两者结合，则是精确匹配

* 量词：设定某个模式出现的次数

  * | 量词  | 说明                   |
    | ----- | ---------------------- |
    | *     | 重复零次或更多次   >=0 |
    | +     | 重复零次或更多次   >=0 |
    | ？    | 重复零次或一次       0 |
    | {n}   | 重复n次                |
    | {n,}  | 重复n次或更多次        |
    | {n,m} | 重复n到m次             |

* 字符类

  * \[ ]   匹配字符集合

    * 检测的字符串只要包含[ ]中任意一个字符，都返回 true 。
    * 使用连字符 - 表示一个范围：`[a-zA-Z]`表示大小写都可以
    *  里面加上 ^  取反符号 :`[^a-z]` 匹配除了小写字母以外的字符

  * . (点)   匹配除换行符之外的任何单个字符

  * 预定义：某些常见模式的简写方式。

    * | 预定类 | 说明                                                       |
      | ------ | ---------------------------------------------------------- |
      | \d     | 匹配0-9任意数字，相当于[0-9]                               |
      | \D     | 匹配所有0-9以外的字符，相当于\[^0-9]                       |
      | \w     | 匹配任意字母、数字、下划线，相当于[A-Za-z0-9_]             |
      | \W     | 除了所有字母、数字、下划线以外的字符，相当于\[^A-Za-z0-9_] |
      | \s     | 匹配空格(包括换行符、制表符、空格符)，相当于[\t\r\n\v\f]   |
      | \S     | 匹配非空格的字符，相当于\[^\t\r\n\v\f]                     |

  * 修饰符：约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等

    * 语法：`/表达式/修饰符`
    * i：单词 ignore 的缩写，正则匹配时字母不区分大小写
    * g：单词 global 的缩写，匹配所有满足正则表达式的结果
    * 如：`/a/i` 

  * replace替换

    * 语法：`字符串.replace(/正则表达式/,'替换的文本')`
    * 由于replace默认只替换符合规则的第一个，若要替换所有，可以带上修饰符g
    * 如：`字符串.replace(/a/ig,'替换的文本')`

### 作用域

#### 局部作用域

##### 1、函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问

##### 2、块作用域

使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。

*  let、const 声明的变量会产生块作用域，var 不会产生块作用域
* 故var会被外部访问到

#### 全局作用域

\<script> 标签 和 .js 文件 的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。全局作用域中声明的变量，任何其它作用域都可以被访问

* 为 window 对象动态添加的属性默认也是全局的，不推荐！
* 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！
* 尽可能少的声明全局变量，防止全局变量被污染

#### 作用域链

作用域链本质上是底层的**变量查找机制。**

* 在函数被执行时，会优先查找当前函数作用域中查找变量
* 如果当前作用域查找不到则会依次**逐级查找父级作用域**直到全局作用域

#### JS垃圾回收机制

* 垃圾回收机制(Garbage Collection)  简称 GC

* 不再用到的内存，没有及时释放，就叫做内存泄漏

* 内存生命周期

  * 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
  * 内存使用：即读写内存，也就是使用变量、函数等 
  * 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 
    *  全局变量一般不会回收(关闭页面回收)；
    *  一般情况下局部变量的值, 不用了, 会被自动回收掉

* 算法说明

  * 栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
  * 堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。

* 引用计数

  * IE采用的引用计数算法, 定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象
  * 算法：
    1. 跟踪记录被引用的次数
    2. 如果被引用了一次，那么就记录次数1,多次引用会累加 ++
    3. 如果减少一个引用就减1
    4. 如果引用次数是0 ，则释放内存

  * 问题
    * 嵌套引用(循环引用) ：如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 

* 标记清除法

  * 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 
  * 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。
  * 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 

#### 闭包

一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

```js
function outer(){
    let i = 1
    function fn(){
        console.log(i)
    }
    return fn
}
const fun = outer()
fun() // 外层函数使用内部函数的变量
```

这样实现了数据私有，无法直接修改参数

问题：可能引起内存泄漏

#### 变量提升

变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量）

* 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为 undefined
3. let/const 声明的变量不存在变量提升
4. 变量提升出现在相同作用域当中
5. 实际开发中推荐先声明再访问变量

### 函数进阶

#### 函数提升

函数提升与变量提升比较类似，是指函数在声明之前即可被调用。

* 函数提升能够使函数的声明调用更灵活
2. 函数表达式不存在提升的现象
3. 函数提升出现在相同作用域当中

```js
// 函数提升
foo()
function foo(){
    console.log('声明之前即被调用')
}

// 不存在提升现象
bar()
var bar = function(){
    console.log('函数表达式不存在提升现象')
}
```

#### 函数参数

##### 1、动态参数

arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参

* arguments 是一个**伪数组**，只存在于函数中
2. arguments 的作用是动态获取函数的实参
3. 可以通过for循环依次得到传递过来的实参

##### 2、剩余参数

 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参，该实参是个真数组

```js
function config(baseURL, ...other){}
```

##### 3、展开运算符

展开运算符(…),将一个数组进行展开

```js
const arr = [1,5,3,8,2]
console.log(...arr) // 1 5 3 8 2
```

#### 箭头函数

##### 1、基本语法

```js
// 普通函数
const fn = function(){
    console.log('我是普通函数')
}

// 箭头函数
const fn = () => {
    console.log('我是箭头函数')
}
```

只有一个参数可以省略小括号

```js
// 普通函数
const fn = function(x){
    return x + x
}

// 箭头函数
const fn = x => {
    return x + x
}
```

如果函数体只有一行代码，可以写到一行上，并且无需写 return 直接返回值

```js
// 普通函数
const fn = function(x, y){
    return x + y
}

// 箭头函数
const fn = (x, y) => x + y
```

加括号的函数体返回对象字面量表达式

```js
const fn = uname => ({uname: uname})
```

##### 2、箭头函数参数

* 普通函数有arguments 动态参数
2. 箭头函数没有 arguments 动态参数，但是有 剩余参数 ..args

```js
const getSum = (...args) => {
    // 函数体
}
```

##### 3、箭头函数this

箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。

在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数

```js
const btn = document.querySelector('.btn')

// 箭头函数此时this指向window
btn.addEventListener('click',() => {
    console.log(this)
})

// 普通函数此时this指向DOM对象
btn.addEventListener('click',function(){
	console.log(this)
})
```

#### 解构赋值

##### 1、数组解构

语法

* 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作 

```js
// 批量赋值
// 方式一
const arr = [1,2,3]
const [a,b,c] = arr
// 方式二
const [a,b,c] = [1,2,3]

// 交换变量
let a = 1
let b = 2; // 必须要有分号，同立即执行函数一样
[b,a] = [a,b]

// 变量多于单元值
const [a,b,c] = [1,2]
// a = 1; b = 2; c = undefined

// 变量少于单元值
const [a,b] = [1,2,3]
// a = 1; b = 2

// 剩余参数解决变量少问题
const [a,b,...arr] = [1,2,3,4]
// a = 1; b = 2; arr = [3,4]

// 防止有undefined传递单元值的情况，可以设置默认值
const [a = 0, b = 0] = [1]
// a = 1; b = 0

//按需导入，忽略某些返回值
const [a,b, ,d] = [1,2,3,4]
// a = 1; b = 2; d = 4

// 支持多维数组的结构
const [a, [b, c]] = [1, [2, 3]]
// a = 1; b = 2; c = 3
```

##### 2、对象解构

语法：

* 赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给与属性名相同的变量
* 注意解构的变量名不要和外面的变量名冲突否则报错
* 对象中找不到与变量名一致的属性时变量值为 undefined

```js
// 普通对象
const user = {
    name: '小明',
    age: 18
}
// 批量赋值，注意变量名一定与对象属性名一致
const {name, age} = user
// name = '小明'; age = 18

// 可以从一个对象中提取变量并同时修改新的变量名
const {name: uname, age} = user
// uname = '小明'; age = 18

// 对象数组
const user = [
    {
    	name: '小明',
    	age: 18
	}
]
const [{name, age}] = user

// 多级对象解构
 const pig = {
      name: '佩奇',
      family: {
        mother: '猪妈妈',
        father: '猪爸爸',
        sister: '乔治'
      },
      age: 6
}
const {name, family: {mother, father, sister}} = pig
```

### 构造函数

#### 深入对象

##### 1、创建对象三种方式

```js
// 利用对象字面量创建对象
const o = {
    name: '小温'
}

// 利用new Object 创建对象
const o = new Object({ name: '小温'})

// 利用构造函数创建对象
function People(name){
    this.name = name
}
const Wen = new People('小温')
```

* 约定：命名以大写字母开头，只能由 "new" 操作符来执行。
* 实例成员：通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。
* 静态成员：构造函数的属性和方法被称为静态成员

#### 内置构造函数

##### 1、Object

* Object.keys(对象)：获取对象中所有属性（键），返回数组

* Object.values(对象)：获取对象中所有属性值，返回数组

* Object. assign(空对象，对象)：常用于对象拷贝

  * 应用：给对象添加属性

  * ```js
    const o = {name = '小温'}
    Object.assign(o,{age = 18})
    // o = {name = '小温', age = 18}
    ```

##### 2、Array

| 方法    | 作用     | 说明                                                         |
| ------- | -------- | ------------------------------------------------------------ |
| forEach | 遍历数组 | 不返回，用于不改变值，经常用于查找打印输出值                 |
| filter  | 过滤数组 | 筛选数组元素，并生成新数组                                   |
| map     | 迭代数组 | 返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据 |
| reduce  | 累计器   | 返回函数累计处理的结果，经常用于求和等                       |

* reduce：`arr.reduce(function(累计值, 当前元素 [,索引号][,源数组]){}, 起始值)`
* 起始值可以省略，如果有则作为第一次累计的起始值

* ![3](images\js\3.png)
* 伪数组转换为真数组：静态方法 Array.from()

##### 3、String

![4](images\js\4.png)

##### 4、Number

常用方法：toFixed(保留位数) 设置保留小数位的长度

### 原型

#### 原型

* 每一个构造函数都有一个 prototype 属性，指向另一个对象，这个对象称为原型对象
* 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
* 直接定义在 prototype 对象上的方法，可以被该构造函数的实例所共享
* 构造函数和原型对象中的this 都指向 实例化的对象

#### constructor 属性

* 每个原型对象里面都有个constructor 属性，指向该原型对象的构造函数

* 使用场景：

  ```js
  function Star(name){
      this.name = name
  }
  Star.prototype = {
      // 因为这里采用赋值的方式给prototype创建方法，它原指向的构造函数会被覆盖，导致它的constructor会指向Object，所以需要手动将其指回原有的构造函数Star
      constructor: Star,
      sing: function(){ console.log('唱歌') },
      dance: function(){ console.log('跳舞') }
  }
  ```

#### 对象原型

* 实例对象都会有一个属性 \__proto__ 指向构造函数的 prototype 原型对象
* 实例对象通过属性 \__proto__，从而找到共享的 prototype 原型对象，使用其属性和方法

#### 原型继承

```js
function People(){
    // 公共的属性和方法
}
function Man(){}
// 继承Person对象
Man.prototype = new Person()
// 指回自己
Man.prototype.constructor = Man
function Woman(){}
Woman.prototype = new Person()
Woman.prototype.constructor = Woman
```

#### 原型链

![5](images\js\5.png)

查找规则

* 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
* 如果没有就查找它的原型（也就是\__proto__指向的 prototype 原型对象）
* 如果还没有就查找原型对象的原型（Object的原型对象）
* 依此类推一直找到 Object 为止（null）
* \__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线
* 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

### 深浅拷贝

#### 浅拷贝

浅拷贝：拷贝的是地址

常见方法：

* 拷贝对象：Object.assgin() / 展开运算符 {...obj} 拷贝对象
* 拷贝数组：Array.prototype.concat() 或者 [...arr]

简单数据类型拷贝值，引用数据类型拷贝的是地址

#### 深拷贝

深拷贝：拷贝的是对象，不是地址

常见方法：

* 通过递归实现深拷贝
* lodash/cloneDeep
  2. 先导入lodash库
  2. `const o = _.cloneDeep(obj)`
* 通过JSON.stringify()实现
  3.   `const o = JSON.parse(JSON.stringify(obj))`

### 异常处理

#### throw抛异常

`throw new Error('失败')`

* throw 抛出异常信息，程序也会终止执行

2. throw 后面跟的是错误提示信息
3. Error 对象配合 throw 使用，能够设置更详细的错误信息

#### try/catch捕获异常

* try...catch 用于捕获错误信息

2. 将预估可能发生错误的代码写在 try 代码段中
3. 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息
4. finally  不管是否有错误，都会执行

#### debugger

在需要打断点的代码处添加 debugger关键字，当一打开浏览器调试，会自动跳到debugger关键字处

### 处理this

#### this指向

##### 1、普通函数this指向

普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】

普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined

##### 2、箭头函数this指向

箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！

* 箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的
* 箭头函数中的this引用的就是最近作用域中的this
* 向外层作用域中，一层一层查找this，直到有this的定义

注意事项：

* 不适用：构造函数，原型函数，dom事件函数等等
* 适用：需要使用上层this的地方

#### 改变this

1、call()

`fun.call(thisArg, arg1, arg2, ...) `

* 立即调用函数，同时改变被调用函数里面的this指向，实参分别传入

2、apply()

`fun.apply(thisArg, [argsArray])`

* 立即调用函数，同时改变被调用函数里面的this指向，实参以数组形式传入

3、bind()

`fun.bind(thisArg, arg1, arg2, ...)`

* bind() 方法不会调用函数。但是能改变函数内部this 指向，返回改变this后的新函数

### 性能优化

#### 防抖

防抖：触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间

##### 1、Lodash 库 实现防抖

```js
box.addEventListener('mousemove', _.debounce(fn, time))
```

##### 2、手动实现

```js
function debonce(fn, t = 500){
    let timeId
    // 将操作放在return里，因为在调用的时候使用的是带括号的防抖函数，会立即调用，返回函数让其可以一直调用
    return function() {
        // 如果有定时器，先清除
        if (timeId) clearTimeout(timeId)
        // 开启定时器
        timeId = setTimeout(function (){
            fn()
        }, t)
    }
}
box.addEventListener('mousemove', debounce(fn, 500))
```

#### 节流

节流：连续触发事件但是在 n 秒中只执行一次函数

##### 1、Lodash 库 实现节流

`box.addEventListener('mousemove', _.throttle(fn, time))`

##### 2、手动实现

```js
function throttle(fn, t = 500){
    let startTime = 0
    return function() {
        let now = Date.now()
        if(now - starTime >= t){
            fn()
            startTime = now
        }
    }
}
box.addEventListener('mousemove', throttle(fn, 500))
```

##### 3、记录上一次视频播放位置案例

两个事件：

* ontimeupdate 事件在视频/音频（audio/video）当前的播放位置发送改变时触发
* onloadeddata 事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频（audio/video）的下一帧时触发

ontimeupdate ， 触发频次太高了，可以设定 1秒钟触发一次

获得当前时间：video.currentTime


# ES6

### ECMASript 6 新特性

#### let关键字

let 关键字用来声明变量，使用let 声明的变量有几个特点： 

* 不允许重复声明 
* 块儿级作用域 
* 不存在变量提升 
* 不影响作用域链 

应用场景：以后声明变量使用let 就对了 

#### const 关键字 

const 关键字用来声明常量，const 声明有以下特点

* 声明必须赋初始值 
* 标识符一般为大写
* 不允许重复声明
* 值不允许修改 
* 块儿级作用域 

注意: 对象属性修改和数组元素变化不会出发const 错误

应用场景：声明对象类型使用const，非对象类型声明选择let 

#### 变量的解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。

* 数组的解构赋值
* 对象的解构赋值
* 复杂解构

#### 模板字符串

模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点： 

* 字符串中可以出现换行符 
* 可以使用 ${xxx} 形式输出变量

#### 简化对象写法 

ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 

#### 箭头函数 

箭头函数的注意点: 

* 如果形参只有一个，则小括号可以省略 
* 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果 
* 箭头函数this 指向声明时所在作用域下 this 的值 
* 箭头函数不能作为构造函数实例化 
* 不能使用arguments 

#### rest 参数

ES6 引入rest 参数，用于获取函数的实参，用来代替arguments，即剩余参数`...args`

#### spread 扩展运算符

将一个数组转为用逗号分隔的参数序列，对数组进行解包。 

* 展开数组
* 展开对象

#### Symbol

##### 1、Symbol 基本使用

ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。

特点：

* Symbol 的值是唯一的，用来解决命名冲突的问题 
* Symbol 值不能与其他数据进行运算 
* Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用Reflect.ownKeys 来获取对象的所有键名 

##### 2、Symbol 内置值 

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| Symbol.hasInstance        | 当其他对象使用instanceof 运算符，判断是否为该对象的实例时，会调用这个方法 |
| Symbol.isConcatSpreadable | 对象的Symbol.isConcatSpreadable 属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 |
| Symbol.species            | 创建衍生对象时，会使用该属性                                 |
| Symbol.match              | 当执行str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值。 |
| Symbol.replace            | 当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.search             | 当该对象被str. search (myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.split              | 当该对象被str. split (myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.iterator           | 对象进行for...of 循环时，会调用Symbol.iterator 方法，返回该对象的默认遍历器 |
| Symbol.toPrimitive        | 该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 |
| Symbol. toStringTag       | 在该对象上面调用toString 方法时，返回该方法的返回值          |
| Symbol. unscopables       | 该对象指定了使用with 关键字时，哪些属性会被with环境排除。    |

#### 迭代器

* ES6 创造了一种新的遍历命令for...of 循环，Iterator 接口主要供for...of 消费 
* 原生具备iterator 接口的数据(可用for of 遍历) 
  * Array、Arguments、Set、Map、String、TypedArray 、NodeList 
* 工作原理
  * 创建一个指针对象，指向当前数据结构的起始位置 
  * 第一次调用对象的next 方法，指针自动指向数据结构的第一个成员 
  * 接下来不断调用next 方法，指针一直往后移动，直到指向最后一个成员 
  * 每调用next 方法返回一个包含value 和done 属性的对象

#### 生成器

生成器函数是ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同 

```js
function * gen(){ 
    yield '一只没有耳朵'; 
    yield '一只没有尾巴'; 
    return '真奇怪'; 
} 
let iterator = gen(); 
console.log(iterator.next()); 
console.log(iterator.next()); 
console.log(iterator.next()); 
```

代码说明： 

* \* 的位置没有限制 
* 生成器函数返回的结果是迭代器对象，调用迭代器对象的next 方法可以得到yield 语句后的值 
* yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次next方法，执行一段代码 
* next 方法可以传递实参，作为yield 语句的返回值 

#### Promise

Promise 是ES6 引入的异步编程的新解决方案。语法上Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。 

* Promise 构造函数: Promise (excutor) {}
* Promise.prototype.then 方法 
* Promise.prototype.catch 方法 

#### Set

集合的属性和方法： 

* size、add、delete、has、clear

#### Map

Map的属性和方法： 

* size、set、get、has、clear

#### class 类

```js
//父类 
class Phone { 
    //构造方法 
    constructor(brand, color, price) { 
        this.brand = brand; 
        this.color = color; 
        this.price = price; 
    } 
    
    //对象方法 
    call() { 
        console.log('我可以打电话!!!') 
    } 
} 

//子类 
class SmartPhone extends Phone { 
 
    constructor(brand, color, price, screen, pixel) { 
        super(brand, color, price); 
        this.screen = screen; 
        this.pixel = pixel; 
    } 
 
    //子类方法 
    photo(){ 
        console.log('我可以拍照!!'); 
    } 

 
    //方法重写 
    call(){ 
        console.log('我可以进行视频通话!!'); 
    } 
 
    //静态方法 
    static run(){ 
        console.log('我可以运行程序') 
    } 
 
    static connect(){ 
        console.log('我可以建立连接') 
    } 
} 
```

#### 数值扩展

##### 1、二进制和八进制

ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b 和0o 表示。 

##### 2、Number.isFinite() 与Number.isNaN()

Number.isFinite() 用来检查一个数值是否为有限的

Number.isNaN() 用来检查一个值是否为NaN 

##### 3、Number.parseInt() 与Number.parseFloat() 

ES6 将全局方法parseInt 和parseFloat，移植到Number 对象上面，使用不变。 

##### 4、Math.trunc 

用于去除一个数的小数部分，返回整数部分。 

##### 5、Number.isInteger 

Number.isInteger() 用来判断一个数值是否为整数 

#### 对象扩展

ES6 新增了一些Object 对象的方法 

* Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）
* Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象 
* \__proto__、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型 

#### 模块化

模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。

模块功能主要由两个命令构成：export 和import。 

* export 命令用于规定模块的对外接口 
* import 命令用于输入其他模块提供的功能 

### ECMASript 7 新特性 

#### Array.prototype.includes 

Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值 

#### 指数操作符

在ES7 中引入指数运算符「**」，用来实现幂运算，功能与Math.pow 结果相同

### ECMASript 8 新特性

#### async 和await

async 和await 两种语法结合可以让异步代码像同步代码一样 

##### 1、async 函数 

1. async 函数的返回值为promise 对象， 
2. promise 对象的结果由async 函数执行的返回值决定 

##### 2、await 表达式 

1. await 必须写在async 函数中
2. await 右侧的表达式一般为promise 对象 
3. await 返回的是promise 成功的值 
4. await 的promise 失败了, 就会抛出异常, 需要通过try...catch 捕获处理 

#### Object.values 和Object.entries 

1. Object.values()方法返回一个给定对象的所有可枚举属性值的数组 
2. Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组 

#### Object.getOwnPropertyDescriptors 

该方法返回指定对象所有自身属性的描述对象 

### ECMASript 9 新特性

#### 正则表达式命名捕获组 

ES9 允许命名捕获组使用符号『?\<>』,这样获取捕获结果可读性更强 

```js
let str = '<a href="http://www.atguigu.com">尚硅谷</a>'; 
const reg = /<a href="(?<url>.*)">(?<text>.*)<\/a>/; 
const result = reg.exec(str); 
console.log(result.groups.url); 
console.log(result.groups.text); 
```

#### 正则表达式反向断言

ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。符号(?<>=xx)

```js
//声明字符串 
let str = 'JS5211314你知道么555啦啦啦'; 
//正向断言 
const reg = /\d+(?=啦)/; 
const result = reg.exec(str); 
 
//反向断言 
const reg = /(?<=么)\d+/; 
const result = reg.exec(str); 
 
console.log(result); 
```

#### 正则表达式dotAll 模式

正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现 

```js
let str = ` 
<ul> 
    <li> 
        <a>肖生克的救赎</a> 
        <p>上映日期: 1994-09-10</p> 
    </li> 
    <li> 
        <a>阿甘正传</a> 
        <p>上映日期: 1994-07-06</p> 
    </li> 
</ul>`; 
//声明正则,?为非贪婪模式，默认情况下，量词是 贪婪的（尽可能多匹配），而 ? 会使其变为 尽可能少匹配。
const reg = /<li>.*?<a>(.*?)<\/a>.*?<p>(.*?)<\/p>/gs; 
//执行匹配 
const result = reg.exec(str); 
let result; 
let data = []; 
while(result = reg.exec(str)){ 
    data.push({title: result[1], time: result[2]}); 
} 
//输出结果 
console.log(data); 
```

### ECMASript 10 新特性 

#### Object.fromEntries 

#### trimStart 和trimEnd 

#### Array.prototype.flat 与 flatMap

#### Symbol.prototype.description

### ECMASript 11 新特性 

#### String.prototype.matchAll 

#### 类的私有属性 

#### Promise.allSettled 

#### 可选链操作符 

#### 动态import 导入 

#### globalThis 对象 



# AJAX

### AJAX 的特点

#### AJAX 的优点

* 可以无需刷新页面而与服务器端进行通信。
* 允许你根据用户事件来更新部分页面内容。

#### AJAX 的缺点

* 没有浏览历史，不能回退
* 存在跨域问题(同源)
* SEO 不友好（对爬虫不友好）

###  AJAX 的使用

#### 核心对象

XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。

#### 使用步骤

1. 创建 XMLHttpRequest 对象
   `var xhr = new XMLHttpRequest();`

2. 设置请求信息

   ```js
   xhr.open(method, url);
   //可以设置请求头，一般不设置
   xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
   ```

3. 发送请求

   `hr.send(body) //get 请求不传 body 参数，只有 post 请求使用`

4. 接收响应

   ```js
   //xhr.responseXML 接收 xml 格式的响应数据
   //xhr.responseText 接收文本格式的响应数据
   
   xhr.onreadystatechange = function (){
       if(xhr.readyState == 4 && xhr.status == 200){
           var text = xhr.responseText;
       	console.log(text);
       }
   }
   ```

###  解决 IE 缓存问题

* 问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。
* 解决方式：浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题
* `xhr.open("get","/testAJAX?t="+Date.now());`

### AJAX 请求状态

xhr.readyState 可以用来查看请求当前的状态
https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState

* 0: 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有被调用。
* 1: 表示 send()方法还没有被调用，仍然可以使用 setRequestHeader()，设定 HTTP请求的头信息。
* 2: 表示 send()方法已经执行，并且头信息和状态码已经收到。
* 3: 表示正在接收服务器传来的 body 部分的数据。
* 4: 表示服务器数据已经完全接收，或者本次接收已经失败了

### jQuery 中的 AJAX

#### get 请求

`$.get(url, [data], [callback], [type])`

* url:请求的 URL 地址。
* data:请求携带的参数。
* callback:载入成功时回调函数。
* type:设置返回内容格式，xml, html, script, json, text, _default。

#### post 请求

`$.post(url, [data], [callback], [type])`

* url:请求的 URL 地址。
* data:请求携带的参数。
* callback:载入成功时回调函数。
* type:设置返回内容格式，xml, html, script, json, text, _default。

### 跨域

#### 同源策略

同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。

同源： 协议、域名、端口号 必须完全相同。

违背同源策略就是跨域。

#### 解决跨域——JSONP

##### 1、JSONP 是什么

JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。

##### 2、JSONP 怎么工作的？

在网页有一些标签天生具有跨域能力，比如：img link iframe script。
JSONP 就是利用 script 标签的跨域能力来发送请求的。

##### 3、JSONP 的使用

1. 动态的创建一个 script 标签

   `var script = document.createElement("script");`

2. 设置 script 的 src，设置回调函数

   ```js
   script.src = "http://localhost:3000/testAJAX?callback=abc";
   function abc(data) {
   	alert(data.name);
   };
   ```

3. 将 script 添加到 body 中

   `document.body.appendChild(script);`

4. 服务器中路由的处理

   ```js
   router.get("/testAJAX" , function (req , res) {
   	console.log("收到请求");
   	var callback = req.query.callback;
   	var obj = {
           name:"孙悟空",
   		age:18
       }
       res.send(callback+"("+JSON.stringify(obj)+")");
   });
   ```

##### jQuery 中的 JSONP

#### 解决跨域——CORS

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS

##### 1、CORS 是什么？

CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源

##### 2、CORS 怎么工作的？

CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。

##### 3、CORS 的使用

主要是服务器端的设置：

```js
router.get("/testAJAX" , function (req , res) {
    //通过 res 来设置响应头，来允许跨域请求
	//res.set("Access-Control-Allow-Origin","http://127.0.0.1:3000");
	res.set("Access-Control-Allow-Origin","*");
	res.send("testAJAX 返回的响应");
});
```







# TypeScript

### 1.【类型声明】

使⽤` : `来对变量或函数形参，进⾏类型声明：

```typescript
let a: string   //变量a只能存储字符串
let b: number   //变量b只能存储数值
let c: boolean  //变量c只能存储布尔值
let d: '你好'	   //还可以写字⾯量类型，但只能被赋值为'你好'，故实际开发用不多
```

### 2.【常见类型】

#### any

* 含义：任意类型，⼀旦将变量类型限制为 any ，那就意味着放弃了对该变量的类型检查。

* ```typescript
  // 明确的表示a的类型是 any —— 【显式的any】
  let a: any 
  // 以下对a的赋值，均⽆警告
  a = 100
  a = '你好'
  a = false
  
  // 没有明确的表示b的类型是any，但TS主动推断出来b是any —— 隐式的any
  let b 
  //以下对b的赋值，均⽆警告
  b = 100
  b = '你好'
  b = false
  ```

*  any 类型的变量，可以赋值给任意类型的变量

* ```typescript
  /* 注意点：any类型的变量，可以赋值给任意类型的变量 */
  let c:any
  c = 9
  
  let x: string
  x = c // ⽆警告
  ```

#### unknown

* 含义：未知类型，适⽤于：起初不确定数据的具体类型，要后期才能确定

* unknown 可以理解为⼀个类型安全的any 

* unknown 会强制开发者在使⽤之前进⾏类型检查，从⽽提供更强的类型安全性。 

* ```typescript
  // 设置a的类型为unknown
  let a: unknown
  a = 'hello'
  
  //第⼀种⽅式：加类型判断
  if(typeof a === 'string'){
    x = a 
    console.log(x)
  }
  
  //第⼆种⽅式：加断⾔
  x = a as string
  
  //第三种⽅式：加断⾔
  x = <string>a
  ```

* 读取 any 类型数据的任何属性都不会报错，⽽ unknown 正好与之相反。

* ```typescript
  let str1: string
  str1 = 'hello'
  str1.toUpperCase() //⽆警告
  
  let str2: any
  str2 = 'hello'
  str2.toUpperCase() //⽆警告
  
  let str3: unknown
  str3 = 'hello';
  str3.toUpperCase() //警告：“str3”的类型为“未知”
  
  // 使⽤断⾔强制指定str3的类型为string
  (str3 as string).toUpperCase() //⽆警告
  ```

#### never

* 含义：任何值都不是，即：不能有值，例如 undefined 、 null 、'' 、0 都不⾏！

* ⼏乎不⽤never 去直接限制变量，因为没有意义

* ```typescript
  /* 指定a的类型为never，那就意味着a以后不能存任何的数据了 */
  let a: never
  
  // 以下对a的所有赋值都会有警告
  a = 1 
  a = true
  a = undefined
  a = null
  ```

*  never ⼀般是TypeScript 主动推断出来的

* ```typescript
  // 指定a的类型为string
  let a: string
  // 给a设置⼀个值
  a = 'hello'
  
  if (typeof a === 'string') {
    console.log(a.toUpperCase())
  } else {
    console.log(a) // TypeScript会推断出此处的a是never，因为没有任何⼀个值符合此处的逻辑
  }
  ```

*  never 也可⽤于限制函数的返回值

* ```typescript
  // 限制throwError函数不需要有任何返回值，任何值都不⾏，像undeifned、null都不⾏
  function throwError(str: string): never {
    throw new Error('程序异常退出:' + str)
  }
  ```

#### void

* 含义：空，即：函数不返回任何值，调⽤者也不应依赖其返回值进⾏任何操作！

*  void 通常⽤于函数返回值声明

*  undefined 和 void 区别：

* ```typescript
  function logMessage(msg:string):void{
    console.log(msg)
  }
  
  let result = logMessage('你好')
  
  if(result){ // 此⾏报错：⽆法测试 "void" 类型的表达式的真实性
    console.log('logMessage有返回值')
  }
  ```

* ```typescript
  function logMessage(msg:string):undefined{
    console.log(msg)
  }
  
  let result = logMessage('你好')
  
  if(result){ // 此⾏⽆警告
    console.log('logMessage有返回值')
  }
  ```

#### object

##### 1、object

* 所有⾮原始类型，可存储：对象、函数、数组等，由于限制的范围⽐较宽泛，在实际开发中使⽤的相对较少。

* ```typescript
  let a:object //a的值可以是任何【⾮原始类型】，包括：对象、函数、数组等
  
  // 以下代码，是将【⾮原始类型】赋给a，所以均符合要求
  a = {}
  a = {name:'张三'}
  a = [1,3,5,7,9]
  a = function(){}
  a = new String('123')
  class Person {}
  a = new Person()
  
  // 以下代码，是将【原始类型】赋给a，有警告
  a = 1         // 警告：不能将类型“number”分配给类型“object”
  a = true      // 警告：不能将类型“boolean”分配给类型“object”
  a = '你好'    // 警告：不能将类型“string”分配给类型“object” 
  a = null      // 警告：不能将类型“null”分配给类型“object”
  a = undefined // 警告：不能将类型“undefined”分配给类型“object”
  ```

##### 2、Object

* 所有可以调⽤ Object ⽅法的类型。即，除了 undefined 和 null 的任何值。

* ```typescript
  let b:Object //b的值必须是Object的实例对象（除去undefined和null的任何值）
  
  // 以下代码，均⽆警告，因为给a赋的值，都是Object的实例对象
  b = {}
  b = {name:'张三'}
  b = [1,3,5,7,9]
  b = function(){}
  b = new String('123')
  class Person {}
  b = new Person()
  b = 1 // 1不是Object的实例对象，但其包装对象是Object的实例
  b = true // truue不是Object的实例对象，但其包装对象是Object的实例
  b = '你好' // “你好”不是Object的实例对象，但其包装对象是Object的实例
  
  // 以下代码均有警告
  b = null      // 警告：不能将类型“null”分配给类型“Object”
  b = undefined // 警告：不能将类型“undefined”分配给类型“Object”
  ```

##### 3、声明对象类型

* ```typescript
  // 限制person1对象必须有name属性，age为可选属性
  let person1: { name: string, age?: number }
  
  // 含义同上，也能⽤分号做分隔
  let person2: { name: string; age?: number }
  
  // 含义同上，也能⽤换⾏做分隔
  let person3: {
    name: string
    age?: number
  }
  ```

* 索引签名： 允许定义对象可以具有任意数量的属性，这些属性的键和类型是可变的，常⽤于：描述类型不确定的属性，（具有动态属性的对象）。

* ```typescript
  // 限制person对象必须有name属性，可选age属性但值必须是数字，同时可以有任意数
  量、任意类型的其他属性
  let person: {
    name: string
    age?: number
    [key: string]: any // 索引签名，完全可以不⽤key这个单词，换成其他的也可以
  }
  ```

##### 4、声明函数类型

```typescript
let count: (a: number, b: number) => number

count = function (x, y) {
  return x + y 
}
```

* TypeScript 中的 => 在函数类型声明时表示函数类型，描述其参数类型和返回类型。
* JavaScript 中的 => 是⼀种定义函数的语法，是具体的函数实现。
* 函数类型声明还可以使⽤：接⼝、⾃定义类型等⽅式。

##### 5、声明数组类型

```typescript
let arr1: string[] 
let arr2: Array<string>

arr1 = ['a','b','c']
arr2 = ['hello','world']
```

#### tuple

* 元组 (Tuple) 是⼀种特殊的数组类型，可以存储固定数量的元素，并且每个元素的类型是已知的且可以不同。元组⽤于精确描述⼀组值的类型， ? 表示可选元素。

* ```typescript
  // 第⼀个元素必须是 string 类型，第⼆个元素必须是 number 类型。
  let arr1: [string,number]
  // 第⼀个元素必须是 number 类型，第⼆个元素是可选的，如果存在，必须是 boolean 类型。
  let arr2: [number,boolean?]
  // 第⼀个元素必须是 number 类型，后⾯的元素可以是任意数量的 string 类型
  let arr3: [number,...string[]]
  
  // 可以赋值
  arr1 = ['hello',123]
  arr2 = [100,false]
  arr2 = [200]
  arr3 = [100,'hello','world']
  arr3 = [100]
  
  // 不可以赋值，arr1声明时是两个元素，赋值的是三个
  arr1 = ['hello',123,false]
  ```

#### enum

枚举（ enum ）可以定义⼀组命名常量，它能增强代码的可读性，也让代码更好维护。

##### 1、数字枚举

* 数字枚举⼀种最常⻅的枚举类型，其成员的值会⾃动递增，且数字枚举还具备反向映射的特点，在下⾯代码的打印中，不难发现：可以通过值来获取对应的枚举成员名称 。

* ```typescript
  // 定义⼀个描述【上下左右】⽅向的枚举Direction
  enum Direction {
    Up,
    Down,
    Left,
    Right
  }
  
  console.log(Direction) // 打印Direction会看到如下内容
  /* 
    {
      0:'Up', 
      1:'Down', 
      2:'Left', 
      3:'Right', 
      Up:0, 
      Down:1, 
      Left:2,
      Right:3
    } 
  */
  
  // 反向映射
  console.log(Direction.Up)
  console.log(Direction[0])
  
  // 此⾏代码报错，枚举中的属性是只读的
  Direction.Up = 'shang'
  ```

* 也可以指定枚举成员的初始值，其后的成员值会⾃动递增

* ```typescript
  enum Direction {
    Up = 6,
    Down,
    Left,
    Right
  }
  
  console.log(Direction.Up); // 输出: 6
  console.log(Direction.Down); // 输出: 7
  ```

##### 2、字符串枚举

枚举成员的值是字符串 

```typescript
enum Direction {
  Up = "up",
  Down = "down",
  Left = "left",
  Right = "right"
}

let dir: Direction = Direction.Up;
console.log(dir); // 输出: "up"
```

##### 3、常量枚举

* 常量枚举是⼀种特殊枚举类型，它使⽤ const 关键字定义，在编译时会被内联，避免⽣成⼀些额外的代码。 

* 编译时内联：所谓“内联”其实就是 TypeScript 在编译时，会将枚举成员引⽤替换为它们的实际值，而不是生成额外的枚举对象。这可以减少生成的 JavaScript 代码量，并提⾼运⾏时性
  能。  

* ```typescript
  // 使⽤普通枚举的 TypeScript 代码
  enum Directions {
    Up,
    Down,
    Left,
    Right
  }
  
  let x = Directions.Up;
  ```

  ```js
  // 编译后⽣成的 JavaScript 代码量较⼤ 
  "use strict";
  var Directions;
  (function (Directions) {
      Directions[Directions["Up"] = 0] = "Up";
      Directions[Directions["Down"] = 1] = "Down";
      Directions[Directions["Left"] = 2] = "Left";
      Directions[Directions["Right"] = 3] = "Right";
  })(Directions || (Directions = {}));
  
  let x = Directions.Up;
  ```

* ```typescript
  // 使⽤常量枚举的 TypeScript 
  const enum Directions {
    Up,
    Down,
    Left,
    Right
  }
  
  let x = Directions.Up;
  ```

  ```js
  // 编译后⽣成的 JavaScript 代码量较⼩
  "use strict";
  let x = 0 /* Directions.Up */;
  ```

#### type

type 可以为任意类型创建别名，让代码更简洁、可读性更强，同时能更⽅便地进⾏类型复⽤和扩展。  

##### 1、基本用法

类型别名使⽤ type 关键字定义， type 后跟类型名称，例如下⾯代码中num 是类型别名。

```typescript
type num = number;

let price: num
price = 100
```

##### 2、联合类型

联合类型是⼀种⾼级类型，它表示⼀个值可以是⼏种不同类型之⼀。

```typescript
type Status = number | string // 可以是数字或者字符串
type Gender = '男' | '⼥' // 只能是 '男' 或者 '女'

function printStatus(status: Status) {
  console.log(status);
}

function logGender(str:Gender){
  console.log(str)
}

printStatus(404);
printStatus('200');
printStatus('501');

logGender('男')
logGender('⼥')
```

##### 3、交叉类型

 交叉类型（Intersection Types）允许将多个类型合并为⼀个类型。合并后的类型将拥有所有被合并类型的成员。交叉类型通常⽤于对象类型。  

```typescript
//⾯积
type Area = {
  height: number; //⾼
  width: number; //宽
};

//地址
type Address = {
  num: number; //楼号
  cell: number; //单元号
  room: string; //房间号
};

// 定义类型House，且House是Area和Address组成的交叉类型
type House = Area & Address;

const house: House = {
  height: 180,
  width: 75,
  num: 6,
  cell: 3,
  room: '702'
};
```

#### 特殊情况

在函数定义时，限制函数返回值为 void ，那么函数的返回值就必须是空。

```typescript
function demo():void{
  // 返回undefined合法
  return undefined

  // 以下返回均不合法
  return 100
  return false
  return null
  return []
}
demo()
```

使⽤ 限制函数返回值为 void 时，**TypeScript 并不会严格要求函数返回空**。

```typescript
type LogFunc = () => void

const f1: LogFunc = () => {
  return 100; // 允许返回⾮空值
};

const f2: LogFunc = () => 200; // 允许返回⾮空值

const f3: LogFunc = function () {
  return 300; // 允许返回⾮空值
};
```

原因：是为了确保如下代码成⽴，我们知道 Array.prototype.push 的返回值是⼀个数字，⽽ Array.prototype.forEach ⽅法期望其回调的返回类型是 void 。

```typescript
const src = [1, 2, 3];
const dst = [0];
 
src.forEach((el) => dst.push(el));
```

#### 属性修饰符

* public、protected、private、readonly

* 在属性、方法最前面添加即可

* 属性简写：

  ```typescript
  // 完整写法
  class Person {
    public name: string;
    public age: number;
  
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
  }
  
  // 简写形式
  class Person {
    constructor( public name: string, public age: number) { }
  }
  ```

* readonly 修饰符

  ```typescript
  class Car {
    constructor(
      public readonly vin: string, //⻋辆识别码，为只读属性
      public readonly year: number,//出⼚年份，为只读属性
      public color: string,
      public sound: string
    ) { }
  }
  ```

### 3.【抽象类】

```typescript
abstract class Package {
  constructor(public weight: number) { }
  // 抽象⽅法：⽤来计算运费，不同类型包裹有不同的计算⽅式
  abstract calculate(): number
  // 通⽤⽅法：打印包裹详情
  printPackage() {
    console.log(`包裹重量为: ${this.weight}kg，运费为: ${this.calculate()}元`);
  }
}
```

### 4.【interface（接口）】

#### 定义类结构

```typescript
interface PersonInterface {
  name: string
  age: number
  speak(n: number): void
}

// 定义⼀个类 Person，实现 PersonInterface 接⼝
class Person implements PersonInterface {
  constructor(
    public name: string,
    public age: number
  ) { }
  // 实现接⼝中的 speak ⽅法
  speak(n: number): void {
    for (let i = 0; i < n; i++) {
      // 打印出包含名字和年龄的问候语句
      console.log(`你好，我叫${this.name}，我的年龄是${this.age}`);
    }
  }
}
```

#### 定义对象结构

```typescript
interface UserInterface {
  name: string
  readonly gender: string // 只读属性
  age?: number // 可选属性
  run: (n: number) => void
}

const user: UserInterface = {
  name: "张三",
  gender: '男',
  age: 18,
  run(n) {
    console.log(`奔跑了${n}⽶`)
  }
};
```

#### 定义函数结构

```typescript
interface CountInterface {
  (a: number, b: number): number;
}

const count: CountInterface = (x, y) => {
  return x + y
}
```

#### 接口之间的继承

```typescript
interface PersonInterface {
  name: string // 姓名
  age: number  // 年龄
}

interface StudentInterface extends PersonInterface {
  grade: string // 年级
}

const stu: StudentInterface = {
  name: "张三",
  age: 25,
  grade: '⾼三',
}
```

#### 接口自动合并（可重复定义）

```typescript
// PersonInterface接⼝
interface PersonInterface {
  // 属性声明
  name: string
  age: number
}

// 给PersonInterface接⼝添加新属性
interface PersonInterface {
  // ⽅法声明
  speak(): void
}

// Person类实现PersonInterface
class Person implements PersonInterface {
  name: string
  age: number
  // 构造器
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
  // ⽅法
  speak() {
    console.log('你好！我是⽼师:', this.name)
  }
}
```

### 5.【相似概念的区别】

#### interface 与 type 的区别

* 相同点： interface 和 type 都可以⽤于定义对象结构，在定义对象结构时两者可以互换。
* 不同点：
  * interface ：更专注于定义对象和类的结构，⽀持继承、合并。
  * type ：可以定义类型别名、联合类型、交叉类型，但不⽀持继承和⾃动合并。

#### interface 与 抽象类的区别

* 相同点：都能定义⼀个类的格式（定义类应遵循的契约）  
* 不相同：
  * 接口：只能描述结构，不能有任何实现代码，⼀个类可以实现多个接口。
  * 抽象类：既可以包含抽象⽅法，也可以包含具体⽅法， ⼀个类只能继承⼀个抽象类。

### 6.【泛型】

#### 泛型函数

```typescript
function logData<T>(data: T): T {
  console.log(data)
  return data
}

logData<number>(100)
logData<string>('hello')
```

#### 泛型接口

```typescript
interface PersonInterface<T> {
  name: string,
  age: number,
  extraInfo: T
}

let p1: PersonInterface<string>
let p2: PersonInterface<number>

p1 = { name: '张三', age: 18, extraInfo: '⼀个好⼈' }
p2 = { name: '李四', age: 18, extraInfo: 250 }
```

#### 泛型约束

```typescript
interface LengthInterface {
  length: number
}

// 约束规则是：传⼊的类型T必须具有 length 属性
function logPerson<T extends LengthInterface>(data: T): void {
  console.log(data.length)
}

logPerson<string>('hello')
// 报错：因为number不具备length属性
// logPerson<number>(100)
```

#### 泛型类 

```typescript
class Person<T> {
  constructor(
    public name: string,
    public age: number,
    public extraInfo: T
  ) { }
  speak() {
    console.log(`我叫${this.name}今年${this.age}岁了`)
    console.log(this.extraInfo)
  }
}

// 测试代码1
const p1 = new Person<number>("tom", 30, 250);

// 测试代码2
type JobInfo = {
  title: string;
  company: string;
}
const p2 = new Person<JobInfo>("tom", 30, { title: '研发总监', company: '发发发
科技公司' });
```

### 7.【类型声明文件】

类型声明⽂件是 TypeScript 中的⼀种特殊⽂件，通常以 .d.ts 作为扩展名。它的主要作⽤是为现有的 JavaScript 代码提供类型信息，使得 TypeScript 能够在使⽤这些 JavaScript 库或模块时进⾏类型检查和提示。  

```typescript
// demo.js 
export function add(a, b) {
  return a + b;
}

export function mul(a, b) {
  return a * b;
}

// demo.d.ts 

declare function add(a: number, b: number): number;
declare function mul(a: number, b: number): number;

export { add, mul };

// index.ts 
import { add, mul } from "./demo.js";

const x = add(2, 3); // x 类型为 number
const y = mul(4, 5); // y 类型为 number

console.log(x,y)
```



# VUE3

## 1.核心语法

### 1.1.【OptionsAPI 与 CompositionAPI】

* `Vue2`的`API`设计是`Options`（配置）风格的。
* `Vue3`的`API`设计是`Composition`（组合）风格的。

#### Options API 的弊端

`Options`类型中，功能所需的数据、方法等是分散的，不便于维护和复用

<img src="images/1696662249851-db6403a1-acb5-481a-88e0-e1e34d2ef53a.gif" alt="3.gif" style="height:300px;border-radius:10px"  /><img src="images/1696662256560-7239b9f9-a770-43c1-9386-6cc12ef1e9c0.gif" alt="4.gif" style="height:300px;border-radius:10px"  />

### 1.2.【setup】

#### 概述

`setup`是`Vue3`中一个新的配置项，值是一个函数，组件中所用到的：数据、方法、计算属性、监视......等等，均配置在`setup`中。

特点如下：

- `setup`函数返回的对象中的内容，可直接在模板中使用。
- `setup`中访问`this`是`undefined`。
- `setup`函数会在`beforeCreate`之前调用，它是“领先”所有钩子执行的。

```vue
<template>
  <div class="person">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

// 声明该script标签使用ts语言写的
<script lang="ts">
  export default {
    name:'Person',
    setup(){
      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）
      let name = '张三'
      let age = 18
      let tel = '13888888888'

      // 方法，原来写在methods中
      function changeName(){
        name = 'zhang-san' //注意：此时这么修改name页面是不变化的
        console.log(name)
      }
      function changeAge(){
        age += 1 //注意：此时这么修改age页面是不变化的
        console.log(age)
      }
      function showTel(){
        alert(tel)
      }

      // 返回一个对象，对象中的内容，模板中可以直接使用
      return {name,age,tel,changeName,changeAge,showTel}
    }
  }
</script>
```

#### setup 的返回值

- 若返回一个**对象**：则对象中的：属性、方法等，在模板中均可以直接使用**（重点关注）。**
- 若返回一个**函数**：则可以自定义渲染内容，代码如下：

```jsx
setup(){
  return ()=> '你好啊！'
}
```

#### setup 与 Options API 的关系

- `Vue2` 的配置（`data`、`methos`......）中**可以访问到** `setup`中的属性、方法。
- 但在`setup`中**不能访问到**`Vue2`的配置（`data`、`methos`......）。
- 如果与`Vue2`冲突，则`setup`优先。

#### setup 语法糖

`setup`函数有一个语法糖，这个语法糖，可以让我们把`setup`独立出去，代码如下：

```vue
<template>
  <div class="person">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changName">修改名字</button>
    <button @click="changAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

<script lang="ts">
  export default {
    name:'Person',
  }
</script>

<!-- 下面的写法是setup语法糖 -->
<script setup lang="ts">
  console.log(this) //undefined
  
  // 数据（注意：此时的name、age、tel都不是响应式数据）
  let name = '张三'
  let age = 18
  let tel = '13888888888'

  // 方法
  function changName(){
    name = '李四'//注意：此时这么修改name页面是不变化的
  }
  function changAge(){
    console.log(age)
    age += 1 //注意：此时这么修改age页面是不变化的
  }
  function showTel(){
    alert(tel)
  }
</script>
```

扩展：上述代码，还需要编写一个不写`setup`的`script`标签，去指定组件名字，比较麻烦，我们可以借助`vite`中的插件简化

1. 第一步：`npm i vite-plugin-vue-setup-extend -D`
2. 第二步：`vite.config.ts`

```jsx
import { defineConfig } from 'vite'
import VueSetupExtend from 'vite-plugin-vue-setup-extend'

export default defineConfig({
  plugins: [ VueSetupExtend() ]
})
```

3. 第三步：`<script setup lang="ts" name="Person">`

### 1.3.【ref 创建：基本类型的响应式数据】

- **作用：**定义响应式变量。
- **语法：**`let xxx = ref(初始值)`。
- **返回值：**一个`RefImpl`的实例对象，简称`ref对象`或`ref`，`ref`对象的`value`**属性是响应式的**。
- **注意点：**
  - `JS`中操作数据需要：`xxx.value`，但模板中不需要`.value`，直接使用即可。
  - 对于`let name = ref('张三')`来说，`name`不是响应式的，`name.value`是响应式的。

```vue
<template>
  <div class="person">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

<script setup lang="ts" name="Person">
  import {ref} from 'vue'
  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。
  let name = ref('张三')
  let age = ref(18)
  // tel就是一个普通的字符串，不是响应式的
  let tel = '13888888888'

  function changeName(){
    // JS中操作ref对象时候需要.value
    name.value = '李四'
    console.log(name.value)

    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。
    // name = ref('zhang-san')
  }
  function changeAge(){
    // JS中操作ref对象时候需要.value
    age.value += 1 
    console.log(age.value)
  }
  function showTel(){
    alert(tel)
  }
</script>
```

### 1.4.【reactive 创建：对象类型的响应式数据】

- **作用：**定义一个**响应式对象**（基本类型不要用它，要用`ref`，否则报错）
- **语法：**`let 响应式对象= reactive(源对象)`。
- **返回值：**一个`Proxy`的实例对象，简称：响应式对象。
- **注意点：**`reactive`定义的响应式数据是“深层次”的。

```vue
<template>
  <div class="person">
    <h2>汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万</h2>
    <h2>游戏列表：</h2>
    <ul>
      <li v-for="g in games" :key="g.id">{{ g.name }}</li>
    </ul>
    <h2>测试：{{obj.a.b.c.d}}</h2>
    <button @click="changeCarPrice">修改汽车价格</button>
    <button @click="changeFirstGame">修改第一游戏</button>
    <button @click="test">测试</button>
  </div>
</template>

<script lang="ts" setup name="Person">
import { reactive } from 'vue'

// 数据
let car = reactive({ brand: '奔驰', price: 100 })
let games = reactive([
  { id: 'ahsgdyfa01', name: '英雄联盟' },
  { id: 'ahsgdyfa02', name: '王者荣耀' },
  { id: 'ahsgdyfa03', name: '原神' }
])
let obj = reactive({
  a:{
    b:{
      c:{
        d:666
      }
    }
  }
})

function changeCarPrice() {
  car.price += 10
}
function changeFirstGame() {
  games[0].name = '流星蝴蝶剑'
}
function test(){
  obj.a.b.c.d = 999
}
</script>
```

### 1.5.【ref 创建：对象类型的响应式数据】

- 其实`ref`接收的数据可以是：**基本类型**、**对象类型**。
- 若`ref`接收的是对象类型，内部其实也是调用了`reactive`函数。

```vue
<template>
  <div class="person">
    <h2>汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万</h2>
    <h2>游戏列表：</h2>
    <ul>
      <li v-for="g in games" :key="g.id">{{ g.name }}</li>
    </ul>
    <h2>测试：{{obj.a.b.c.d}}</h2>
    <button @click="changeCarPrice">修改汽车价格</button>
    <button @click="changeFirstGame">修改第一游戏</button>
    <button @click="test">测试</button>
  </div>
</template>

<script lang="ts" setup name="Person">
import { ref } from 'vue'

// 数据
let car = ref({ brand: '奔驰', price: 100 })
let games = ref([
  { id: 'ahsgdyfa01', name: '英雄联盟' },
  { id: 'ahsgdyfa02', name: '王者荣耀' },
  { id: 'ahsgdyfa03', name: '原神' }
])
let obj = ref({
  a:{
    b:{
      c:{
        d:666
      }
    }
  }
})

console.log(car)

function changeCarPrice() {
  car.value.price += 10
}
function changeFirstGame() {
  games.value[0].name = '流星蝴蝶剑'
}
function test(){
  obj.value.a.b.c.d = 999
}
</script>
```

### 1.6.【ref 对比 reactive】

宏观角度看：

> 1. `ref`用来定义：**基本类型数据**、**对象类型数据**；
>
> 2. `reactive`用来定义：**对象类型数据**。

- 区别：

> 1. `ref`创建的变量必须使用`.value`（可以使用`volar`插件自动添加`.value`）。
>
>    <img src="images/自动补充value.png" alt="自动补充value" style="zoom:50%;border-radius:20px" /> 
>
> 2. `reactive`重新分配一个新对象，会**失去**响应式（可以使用`Object.assign`去整体替换）。

- 使用原则：

> 1. 若需要一个基本类型的响应式数据，必须使用`ref`。
> 2. 若需要一个响应式对象，层级不深，`ref`、`reactive`都可以。
> 3. 若需要一个响应式对象，且层级较深，推荐使用`reactive`。

### 1.7. 【toRefs 与 toRef】

- 作用：将一个响应式对象中的每一个属性，转换为`ref`对象。
- 备注：`toRefs`与`toRef`功能一致，但`toRefs`可以批量转换。
- 语法如下：

```vue
<template>
  <div class="person">
    <h2>姓名：{{person.name}}</h2>
    <h2>年龄：{{person.age}}</h2>
    <h2>性别：{{person.gender}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="changeGender">修改性别</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {ref,reactive,toRefs,toRef} from 'vue'

  // 数据
  let person = reactive({name:'张三', age:18, gender:'男'})
	
  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力
  let {name,gender} =  toRefs(person)
	
  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力
  let age = toRef(person,'age')

  // 方法
  function changeName(){
    name.value += '~'
  }
  function changeAge(){
    age.value += 1
  }
  function changeGender(){
    gender.value = '女'
  }
</script>
```

### 1.8. 【computed】

作用：根据已有数据计算出新数据（和`Vue2`中的`computed`作用一致）。

<img src="images/computed.gif" style="zoom:20%;" />  

```vue
<template>
  <div class="person">
    姓：<input type="text" v-model="firstName"> <br>
    名：<input type="text" v-model="lastName"> <br>
    全名：<span>{{fullName}}</span> <br>
    <button @click="changeFullName">全名改为：li-si</button>
  </div>
</template>

<script setup lang="ts" name="App">
  import {ref,computed} from 'vue'

  let firstName = ref('zhang')
  let lastName = ref('san')

  // 计算属性——只读取，不修改
  /* let fullName = computed(()=>{
    return firstName.value + '-' + lastName.value
  }) */


  // 计算属性——既读取又修改
  let fullName = computed({
    // 读取
    get(){
      return firstName.value + '-' + lastName.value
    },
    // 修改
    set(val){
      console.log('有人修改了fullName',val)
      firstName.value = val.split('-')[0]
      lastName.value = val.split('-')[1]
    }
  })

  function changeFullName(){
    fullName.value = 'li-si'
  } 
</script>
```

### 1.9.【watch】

- 作用：监视数据的变化（和`Vue2`中的`watch`作用一致）
- 特点：`Vue3`中的`watch`只能监视以下**四种数据**：

> 1. `ref`定义的数据。
> 2. `reactive`定义的数据。
> 3. 函数返回一个值（`getter`函数）。
> 4. 一个包含上述内容的数组。

我们在`Vue3`中使用`watch`的时候，通常会遇到以下几种情况：

#### * 情况一

监视`ref`定义的【基本类型】数据：直接写数据名即可，监视的是其`value`值的改变。

```vue
<template>
  <div class="person">
    <h1>情况一：监视【ref】定义的【基本类型】数据</h1>
    <h2>当前求和为：{{sum}}</h2>
    <button @click="changeSum">点我sum+1</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {ref,watch} from 'vue'
  // 数据
  let sum = ref(0)
  // 方法
  function changeSum(){
    sum.value += 1
  }
  // 监视，情况一：监视【ref】定义的【基本类型】数据
  const stopWatch = watch(sum,(newValue,oldValue)=>{
    console.log('sum变化了',newValue,oldValue)
    if(newValue >= 10){
      stopWatch()
    }
  })
</script>
```

#### * 情况二

监视`ref`定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。

> 注意：
>
> * 若修改的是`ref`定义的对象中的属性，`newValue` 和 `oldValue` 都是新值，因为它们是同一个对象。
>
> * 若修改整个`ref`定义的对象，`newValue` 是新值， `oldValue` 是旧值，因为不是同一个对象了。

```vue
<template>
  <div class="person">
    <h1>情况二：监视【ref】定义的【对象类型】数据</h1>
    <h2>姓名：{{ person.name }}</h2>
    <h2>年龄：{{ person.age }}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="changePerson">修改整个人</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {ref,watch} from 'vue'
  // 数据
  let person = ref({
    name:'张三',
    age:18
  })
  // 方法
  function changeName(){
    person.value.name += '~'
  }
  function changeAge(){
    person.value.age += 1
  }
  function changePerson(){
    person.value = {name:'李四',age:90}
  }
  /* 
    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视
    watch的第一个参数是：被监视的数据
    watch的第二个参数是：监视的回调
    watch的第三个参数是：配置对象（deep、immediate等等.....） 
  */
  watch(person,(newValue,oldValue)=>{
    console.log('person变化了',newValue,oldValue)
  },{deep:true})
  
</script>
```

#### *  情况三

监视`reactive`定义的【对象类型】数据，且默认开启了深度监视。

```vue
<template>
  <div class="person">
    <h1>情况三：监视【reactive】定义的【对象类型】数据</h1>
    <h2>姓名：{{ person.name }}</h2>
    <h2>年龄：{{ person.age }}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="changePerson">修改整个人</button>
    <hr>
    <h2>测试：{{obj.a.b.c}}</h2>
    <button @click="test">修改obj.a.b.c</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {reactive,watch} from 'vue'
  // 数据
  let person = reactive({
    name:'张三',
    age:18
  })
  let obj = reactive({
    a:{
      b:{
        c:666
      }
    }
  })
  // 方法
  function changeName(){
    person.name += '~'
  }
  function changeAge(){
    person.age += 1
  }
  function changePerson(){
    Object.assign(person,{name:'李四',age:80})
  }
  function test(){
    obj.a.b.c = 888
  }

  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的
  watch(person,(newValue,oldValue)=>{
    console.log('person变化了',newValue,oldValue)
  })
  watch(obj,(newValue,oldValue)=>{
    console.log('Obj变化了',newValue,oldValue)
  })
</script>
```

#### * 情况四

监视`ref`或`reactive`定义的【对象类型】数据中的**某个属性**，注意点如下：

1. 若该属性值**不是**【对象类型】，需要写成函数形式。
2. 若该属性值是**依然**是【对象类型】，可直接编，也可写成函数，建议写成函数。

结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。

```vue
<template>
  <div class="person">
    <h1>情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性</h1>
    <h2>姓名：{{ person.name }}</h2>
    <h2>年龄：{{ person.age }}</h2>
    <h2>汽车：{{ person.car.c1 }}、{{ person.car.c2 }}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="changeC1">修改第一台车</button>
    <button @click="changeC2">修改第二台车</button>
    <button @click="changeCar">修改整个车</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {reactive,watch} from 'vue'

  // 数据
  let person = reactive({
    name:'张三',
    age:18,
    car:{
      c1:'奔驰',
      c2:'宝马'
    }
  })
  // 方法
  function changeName(){
    person.name += '~'
  }
  function changeAge(){
    person.age += 1
  }
  function changeC1(){
    person.car.c1 = '奥迪'
  }
  function changeC2(){
    person.car.c2 = '大众'
  }
  function changeCar(){
    person.car = {c1:'雅迪',c2:'爱玛'}
  }

  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式
  /* watch(()=> person.name,(newValue,oldValue)=>{
    console.log('person.name变化了',newValue,oldValue)
  }) */

  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数
  watch(()=>person.car,(newValue,oldValue)=>{
    console.log('person.car变化了',newValue,oldValue)
  },{deep:true})
</script>
```

#### * 情况五

监视上述的多个数据

```vue
<template>
  <div class="person">
    <h1>情况五：监视上述的多个数据</h1>
    <h2>姓名：{{ person.name }}</h2>
    <h2>年龄：{{ person.age }}</h2>
    <h2>汽车：{{ person.car.c1 }}、{{ person.car.c2 }}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">修改年龄</button>
    <button @click="changeC1">修改第一台车</button>
    <button @click="changeC2">修改第二台车</button>
    <button @click="changeCar">修改整个车</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {reactive,watch} from 'vue'

  // 数据
  let person = reactive({
    name:'张三',
    age:18,
    car:{
      c1:'奔驰',
      c2:'宝马'
    }
  })
  // 方法
  function changeName(){
    person.name += '~'
  }
  function changeAge(){
    person.age += 1
  }
  function changeC1(){
    person.car.c1 = '奥迪'
  }
  function changeC2(){
    person.car.c2 = '大众'
  }
  function changeCar(){
    person.car = {c1:'雅迪',c2:'爱玛'}
  }

  // 监视，情况五：监视上述的多个数据
  watch([()=>person.name,person.car],(newValue,oldValue)=>{
    console.log('person.car变化了',newValue,oldValue)
  },{deep:true})

</script>
```

### 1.10. 【watchEffect】

* 官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。

* `watch`对比`watchEffect`

  > 1. 都能监听响应式数据的变化，不同的是监听数据变化的方式不同
  >
  > 2. `watch`：要明确指出监视的数据
  >
  > 3. `watchEffect`：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。

* 示例代码：

  ```vue
  <template>
    <div class="person">
      <h1>需求：水温达到50℃，或水位达到20cm，则联系服务器</h1>
      <h2 id="demo">水温：{{temp}}</h2>
      <h2>水位：{{height}}</h2>
      <button @click="changePrice">水温+1</button>
      <button @click="changeSum">水位+10</button>
    </div>
  </template>
  
  <script lang="ts" setup name="Person">
    import {ref,watch,watchEffect} from 'vue'
    // 数据
    let temp = ref(0)
    let height = ref(0)
  
    // 方法
    function changePrice(){
      temp.value += 10
    }
    function changeSum(){
      height.value += 1
    }
  
    // 用watch实现，需要明确的指出要监视：temp、height
    watch([temp,height],(value)=>{
      // 从value中获取最新的temp值、height值
      const [newTemp,newHeight] = value
      // 室温达到50℃，或水位达到20cm，立刻联系服务器
      if(newTemp >= 50 || newHeight >= 20){
        console.log('联系服务器')
      }
    })
  
    // 用watchEffect实现，不用
    const stopWtach = watchEffect(()=>{
      // 室温达到50℃，或水位达到20cm，立刻联系服务器
      if(temp.value >= 50 || height.value >= 20){
        console.log(document.getElementById('demo')?.innerText)
        console.log('联系服务器')
      }
      // 水温达到100，或水位达到50，取消监视
      if(temp.value === 100 || height.value === 50){
        console.log('清理了')
        stopWtach()
      }
    })
  </script>
  ```

  

### 1.11. 【标签的 ref 属性】

作用：用于注册模板引用。

> * 用在普通`DOM`标签上，获取的是`DOM`节点。
>
> * 用在组件标签上，获取的是组件实例对象。

用在普通`DOM`标签上：

```vue
<template>
  <div class="person">
    <h1 ref="title1">尚硅谷</h1>
    <h2 ref="title2">前端</h2>
    <h3 ref="title3">Vue</h3>
    <input type="text" ref="inpt"> <br><br>
    <button @click="showLog">点我打印内容</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {ref} from 'vue'
	
  let title1 = ref()
  let title2 = ref()
  let title3 = ref()

  function showLog(){
    // 通过id获取元素
    const t1 = document.getElementById('title1')
    // 打印内容
    console.log((t1 as HTMLElement).innerText)
    console.log((<HTMLElement>t1).innerText)
    console.log(t1?.innerText)
    
		/************************************/
		
    // 通过ref获取元素
    console.log(title1.value)
    console.log(title2.value)
    console.log(title3.value)
  }
</script>
```

用在组件标签上：

```vue
<!-- 父组件App.vue -->
<template>
  <Person ref="ren"/>
  <button @click="test">测试</button>
</template>

<script lang="ts" setup name="App">
  import Person from './components/Person.vue'
  import {ref} from 'vue'

  let ren = ref()

  function test(){
    console.log(ren.value.name)
    console.log(ren.value.age)
  }
</script>


<!-- 子组件Person.vue中要使用defineExpose暴露内容 -->
<script lang="ts" setup name="Person">
  import {ref,defineExpose} from 'vue'
	// 数据
  let name = ref('张三')
  let age = ref(18)
  /****************************/
  /****************************/
  // 使用defineExpose将组件中的数据交给外部
  defineExpose({name,age})
</script>
```



### 1.12. 【props】

> ```js
> // 定义一个接口，限制每个Person对象的格式
> export interface PersonInter {
> id:string,
> name:string,
>  age:number
> }
> 
> // 定义一个自定义类型Persons
> export type Persons = Array<PersonInter>
> ```
>
> `App.vue`中代码：
>
> ```vue
> <template>
> 	<Person :list="persons"/>
> </template>
> 
> <script lang="ts" setup name="App">
> import Person from './components/Person.vue'
> import {reactive} from 'vue'
>  import {type Persons} from './types'
> 
>  let persons = reactive<Persons>([
>   {id:'e98219e12',name:'张三',age:18},
>    {id:'e98219e13',name:'李四',age:19},
>     {id:'e98219e14',name:'王五',age:20}
>   ])
> </script>
> 
> ```
>
> `Person.vue`中代码：
>
> ```Vue
> <template>
> <div class="person">
> <ul>
>   <li v-for="item in list" :key="item.id">
>      {{item.name}}--{{item.age}}
>    </li>
>  </ul>
> </div>
> </template>
> 
> <script lang="ts" setup name="Person">
> import {defineProps} from 'vue'
> import {type PersonInter} from '@/types'
> 
> // 第一种写法：仅接收
> // const props = defineProps(['list'])
> 
> // 第二种写法：接收+限制类型
> // defineProps<{list:Persons}>()
> 
> // 第三种写法：接收+限制类型+指定默认值+限制必要性
> let props = withDefaults(defineProps<{list?:Persons}>(),{
>   list:()=>[{id:'asdasg01',name:'小猪佩奇',age:18}]
> })
> console.log(props)
> </script>
> ```

### 1.13. 【生命周期】

* 概念：`Vue`组件实例在创建时要经历一系列的初始化步骤，在此过程中`Vue`会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子

* 规律：

  > 生命周期整体分为四个阶段，分别是：**创建、挂载、更新、销毁**，每个阶段都有两个钩子，一前一后。

* `Vue2`的生命周期

  > 创建阶段：`beforeCreate`、`created`
  >
  > 挂载阶段：`beforeMount`、`mounted`
  >
  > 更新阶段：`beforeUpdate`、`updated`
  >
  > 销毁阶段：`beforeDestroy`、`destroyed`

* `Vue3`的生命周期

  > 创建阶段：`setup`
  >
  > 挂载阶段：`onBeforeMount`、`onMounted`
  >
  > 更新阶段：`onBeforeUpdate`、`onUpdated`
  >
  > 卸载阶段：`onBeforeUnmount`、`onUnmounted`

* 常用的钩子：`onMounted`(挂载完毕)、`onUpdated`(更新完毕)、`onBeforeUnmount`(卸载之前)

* 示例代码：

  ```vue
  <template>
    <div class="person">
      <h2>当前求和为：{{ sum }}</h2>
      <button @click="changeSum">点我sum+1</button>
    </div>
  </template>
  
  <!-- vue3写法 -->
  <script lang="ts" setup name="Person">
    import { 
      ref, 
      onBeforeMount, 
      onMounted, 
      onBeforeUpdate, 
      onUpdated, 
      onBeforeUnmount, 
      onUnmounted 
    } from 'vue'
  
    // 数据
    let sum = ref(0)
    // 方法
    function changeSum() {
      sum.value += 1
    }
    console.log('setup')
    // 生命周期钩子
    onBeforeMount(()=>{
      console.log('挂载之前')
    })
    onMounted(()=>{
      console.log('挂载完毕')
    })
    onBeforeUpdate(()=>{
      console.log('更新之前')
    })
    onUpdated(()=>{
      console.log('更新完毕')
    })
    onBeforeUnmount(()=>{
      console.log('卸载之前')
    })
    onUnmounted(()=>{
      console.log('卸载完毕')
    })
  </script>
  ```

### 1.14. 【自定义hook】

- 什么是`hook`？—— 本质是一个函数，把`setup`函数中使用的`Composition API`进行了封装，类似于`vue2.x`中的`mixin`。

- 自定义`hook`的优势：复用代码, 让`setup`中的逻辑更清楚易懂。

示例代码：

- `useSum.ts`中内容如下：

  ```js
  import {ref,onMounted} from 'vue'
  
  export default function(){
    let sum = ref(0)
  
    const increment = ()=>{
      sum.value += 1
    }
    const decrement = ()=>{
      sum.value -= 1
    }
    onMounted(()=>{
      increment()
    })
  
    //向外部暴露数据
    return {sum,increment,decrement}
  }		
  ```

- `useDog.ts`中内容如下：

  ```js
  import {reactive,onMounted} from 'vue'
  import axios,{AxiosError} from 'axios'
  
  export default function(){
    let dogList = reactive<string[]>([])
  
    // 方法
    async function getDog(){
      try {
        // 发请求
        let {data} = await axios.get('https://dog.ceo/api/breed/pembroke/images/random')
        // 维护数据
        dogList.push(data.message)
      } catch (error) {
        // 处理错误
        const err = <AxiosError>error
        console.log(err.message)
      }
    }
  
    // 挂载钩子
    onMounted(()=>{
      getDog()
    })
  	
    //向外部暴露数据
    return {dogList,getDog}
  }
  ```

- 组件中具体使用：

  ```vue
  <template>
    <h2>当前求和为：{{sum}}</h2>
    <button @click="increment">点我+1</button>
    <button @click="decrement">点我-1</button>
    <hr>
    <img v-for="(u,index) in dogList.urlList" :key="index" :src="(u as string)"> 
    <span v-show="dogList.isLoading">加载中......</span><br>
    <button @click="getDog">再来一只狗</button>
  </template>
  
  <script lang="ts">
    import {defineComponent} from 'vue'
  
    export default defineComponent({
      name:'App',
    })
  </script>
  
  <script setup lang="ts">
    import useSum from './hooks/useSum'
    import useDog from './hooks/useDog'
  	
    let {sum,increment,decrement} = useSum()
    let {dogList,getDog} = useDog()
  </script>
  ```




## 2.路由

### 2.1【基本切换效果】

- `Vue3`中要使用`vue-router`的最新版本，目前是`4`版本。

- 路由配置文件代码如下：

  ```js
  import {createRouter,createWebHistory} from 'vue-router'
  import Home from '@/pages/Home.vue'
  import News from '@/pages/News.vue'
  import About from '@/pages/About.vue'
  
  const router = createRouter({
  	history:createWebHistory(),
  	routes:[
  		{
  			path:'/home',
  			component:Home
  		},
  		{
  			path:'/about',
  			component:About
  		}
  	]
  })
  export default router
  ```

* `main.ts`代码如下：

  ```js
  import router from './router/index'
  app.use(router)
  
  app.mount('#app')
  ```

- `App.vue`代码如下

  ```vue
  <template>
    <div class="app">
      <h2 class="title">Vue路由测试</h2>
      <!-- 导航区 -->
      <div class="navigate">
        <RouterLink to="/home" active-class="active">首页</RouterLink>
        <RouterLink to="/news" active-class="active">新闻</RouterLink>
        <RouterLink to="/about" active-class="active">关于</RouterLink>
      </div>
      <!-- 展示区 -->
      <div class="main-content">
        <RouterView></RouterView>
      </div>
    </div>
  </template>
  
  <script lang="ts" setup name="App">
    import {RouterLink,RouterView} from 'vue-router'  
  </script>
  ```

### 2.2. 【两个注意点】

> 1. 路由组件通常存放在`pages` 或 `views`文件夹，一般组件通常存放在`components`文件夹。
>
> 2. 通过点击导航，视觉效果上“消失” 了的路由组件，默认是被**卸载**掉的，需要的时候再去**挂载**。

### 2.3.【路由器工作模式】

1. `history`模式

   > 优点：`URL`更加美观，不带有`#`，更接近传统的网站`URL`。
   >
   > 缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有`404`错误。
   >
   > ```js
   > const router = createRouter({
   > 	history:createWebHistory(), //history模式
   > 	/******/
   > })
   > ```

2. `hash`模式

   > 优点：兼容性更好，因为不需要服务器端处理路径。
   >
   > 缺点：`URL`带有`#`不太美观，且在`SEO`优化方面相对较差。
   >
   > ```js
   > const router = createRouter({
   > 	history:createWebHashHistory(), //hash模式
   > 	/******/
   > })
   > ```

### 2.4. 【to的两种写法】

```vue
<!-- 第一种：to的字符串写法 -->
<router-link active-class="active" to="/home">主页</router-link>

<!-- 第二种：to的对象写法 -->
<router-link active-class="active" :to="{path:'/home'}">Home</router-link>
```

### 2.5. 【命名路由】

作用：可以简化路由跳转及传参（后面就讲）。

给路由规则命名：

```js
routes:[
  {
    name:'zhuye',
    path:'/home',
    component:Home
  },
  {
    name:'xinwen',
    path:'/news',
    component:News,
  },
  {
    name:'guanyu',
    path:'/about',
    component:About
  }
]
```

跳转路由：

```vue
<!--简化前：需要写完整的路径（to的字符串写法） -->
<router-link to="/news/detail">跳转</router-link>

<!--简化后：直接通过名字跳转（to的对象写法配合name属性） -->
<router-link :to="{name:'guanyu'}">跳转</router-link>
```



### 2.6. 【嵌套路由】

1. 编写`News`的子路由：`Detail.vue`

2. 配置路由规则，使用`children`配置项：

   ```ts
   const router = createRouter({
     history:createWebHistory(),
   	routes:[
   		{
   			name:'zhuye',
   			path:'/home',
   			component:Home
   		},
   		{
   			name:'xinwen',
   			path:'/news',
   			component:News,
   			children:[
   				{
   					name:'xiang',
   					path:'detail',
   					component:Detail
   				}
   			]
   		},
   		{
   			name:'guanyu',
   			path:'/about',
   			component:About
   		}
   	]
   })
   export default router
   ```

3. 跳转路由（记得要加完整路径）：

   ```vue
   <router-link to="/news/detail">xxxx</router-link>
   <!-- 或 -->
   <router-link :to="{path:'/news/detail'}">xxxx</router-link>
   ```

4. 记得去`Home`组件中预留一个`<router-view>`

   ```vue
   <template>
     <div class="news">
       <nav class="news-list">
         <RouterLink v-for="news in newsList" :key="news.id" :to="{path:'/news/detail'}">
           {{news.name}}
         </RouterLink>
       </nav>
       <div class="news-detail">
         <RouterView/>
       </div>
     </div>
   </template>
   ```

   

### 2.7. 【路由传参】

#### query参数

   1. 传递参数

      ```vue
      <!-- 跳转并携带query参数（to的字符串写法） -->
      <router-link to="/news/detail?a=1&b=2&content=欢迎你">
      	跳转
      </router-link>
      				
      <!-- 跳转并携带query参数（to的对象写法） -->
      <RouterLink 
        :to="{
          //name:'xiang', //用name也可以跳转
          path:'/news/detail',
          query:{
            id:news.id,
            title:news.title,
            content:news.content
          }
        }"
      >
        {{news.title}}
      </RouterLink>
      ```

   2. 接收参数：

      ```js
      import {useRoute} from 'vue-router'
      const route = useRoute()
      // 打印query参数
      console.log(route.query)
      ```


#### params参数

   1. 传递参数

      ```vue
      <!-- 跳转并携带params参数（to的字符串写法） -->
      <RouterLink :to="`/news/detail/001/新闻001/内容001`">{{news.title}}</RouterLink>
      				
      <!-- 跳转并携带params参数（to的对象写法） -->
      <RouterLink 
        :to="{
          name:'xiang', //用name跳转
          params:{
            id:news.id,
            title:news.title,
            content:news.title
          }
        }"
      >
        {{news.title}}
      </RouterLink>
      ```

   2. 接收参数：

      ```js
      import {useRoute} from 'vue-router'
      const route = useRoute()
      // 打印params参数
      console.log(route.params)
      ```

> 备注1：传递`params`参数时，若使用`to`的对象写法，必须使用`name`配置项，不能用`path`。
>
> 备注2：传递`params`参数时，需要提前在规则中占位。

### 2.8. 【路由的props配置】

作用：让路由组件更方便的收到参数（可以将路由参数作为`props`传给组件）

```js
{
	name:'xiang',
	path:'detail/:id/:title/:content',
	component:Detail,

  // props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件
  // props:{a:1,b:2,c:3}, 

  // props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件
  // props:true
  
  // props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件
  props(route){
    return route.query
  }
}
```

### 2.9. 【 replace属性】

  1. 作用：控制路由跳转时操作浏览器历史记录的模式。

  2. 浏览器的历史记录有两种写入方式：分别为```push```和```replace```：

     - ```push```是追加历史记录（默认值）。
     - `replace`是替换当前记录。

  3. 开启`replace`模式：

     ```vue
     <RouterLink replace .......>News</RouterLink>
     ```

### 2.10. 【编程式导航】

路由组件的两个重要的属性：`$route`和`$router`变成了两个`hooks`

```js
import {useRoute,useRouter} from 'vue-router'

const route = useRoute()
const router = useRouter()

console.log(route.query)
console.log(route.parmas)
console.log(router.push)
console.log(router.replace)
```

### 2.11. 【重定向】

1. 作用：将特定的路径，重新定向到已有路由。

2. 具体编码：

   ```js
   {
       path:'/',
       redirect:'/about'
   }
   ```



























