# HTML

#### 基础标签

* 标题标签\<h1>-\<h6>
* 段落标签\<p>
* 换行标签\<br/>

#### 文本格式化标签

* **加粗\<strong>/\<b>**
* **倾斜\<em>/\<i>**
* 删除线\<del>/\<s>
* 下划线\<ins>/\<u>

#### 盒子

* 大盒子\<div>
* 小盒子\<span>

#### 图像标签\<img>

* `<img src="路径" alt="替换文本" titile="提示文本" width="宽度" height="高度" border="边框粗细"/>`

#### 超链接标签\<a>

* `<a href="跳转目标" target="目标窗口的弹出方式"> 文本或图像 </a>`

#### 注释\<!-- 注释语句 -->

#### 特殊字符

* 空格符\&nbsp;
* 大于号\&lt;
* 小于号\&gt;

#### 表格标签

* 基本语法

  ```html
  <table>		// 定义表格标签
  	<tr>	// 定义表格的行
          <th>表头单元格</th>		 // 定义表格的表头	
          <td>单元格内的文字</td>	// 定义表格的单元格
  	</tr>
  </table>`
  ```

* 表格结构标签(放在\<table>\</table>标签中)

  * 表格头部区域\<thead>
  * 表格主体区域\<tbody>

* 合并单元格

  * 跨行合并 rowspan="合并单元格的个数"
  * 跨列合并 colspan="合并单元格的个数"

#### 列表标签

* 无序列表

  ```html
  <ul>
  	<li>列表项1</li>
  	<li>列表项2</li>
  	<li>列表项3</li>
  	...
  </ul>
  ```

* 有序列表

  ```html
  <ol>
  	<li>列表项1</li>
  	<li>列表项2</li>
  	<li>列表项3</li>
  	...
  </ol>
  ```

* 自定义列表

  ```html
  <dl>
  	<dt>名词1</dt>
  	<dd>名词1解释1</dd>
  	<dd>名词1解释2</dd>
      <dt>名词2</dt>
      ...
  </dl>
  ```

#### 表单标签

* 表单域\<from>：`<form action=“url地址” method=“提交方式” name=“表单域名称">各种表单元素控件</form>`

* 表单控件

  * 输入表单元素\<input>：

    `<input type="属性值" name="该元素名称" value="值" checked="首次是否选中" maxlength="输入的最大长度"/>`

    * type属性值

      * 上传文件file
      * 隐藏的输入字段hidden
      * 图像提交image
      * 密码字段password
      * 按钮button
      * 单选按钮radio
      * 复选框checkbox
      * 重置按钮reset
      * 提交按钮submit
      * 文本框text

    * \<label>：绑定表单元素

      ```html
      <label for="sex">男</label> // 当点击"男"时，会自动跳转到对应的表单标签
      <input type="radio" name="sex" id="sex" />
      ```

  * 下拉列表标签\<select>

    ```html
    <select>
    	<option>选项1</option>
    	<option>选项2</option>
    	<option>选项3</option>
    	...
    </select>
    ```

  * 多行文本输入标签\<textarea>：`<textarea rows="显示的行数" cols="每行中的字符数">文本内容</textarea>`

#### 语义化标签

* \<header>头部标签、\<nav>导航标签、\<article>内容标签、\<section>定义文档某个区域、\<aside>侧边栏标签、\<footer>尾部标签
* 特点：
  * 这种语义化标准主要是针对搜索引擎的
  * 这些新标签页面中可以使用多次
  * 在 IE9 中，需要把这些元素转换为块级元素

#### 多媒体标签

* \<audio>音频

  ```css
  <audio src="文件地址" controls="controls"></audio>
  
  <audio controls="controls" >
  	<source src="happy.mp3" type="audio/mpeg" >
  	<source src="happy.ogg" type="audio/ogg" >
  	您的浏览器暂不支持 <audio> 标签。
  </audio>
  ```

* \<video>视频

  ```html
  <video src="文件地址" controls="controls"></video>
  
  <video controls="controls" width="300">
  	<source src="move.ogg" type="video/ogg" >
  	<source src="move.mp4" type="video/mp4" >
  	您的浏览器暂不支持 <video> 标签播放视频
  </ video >
  ```

* 多媒体标签总结

  * 音频标签和视频标签使用方式基本一致
  * 浏览器支持情况不同
  * 谷歌浏览器把音频和视频自动播放禁止了
  * 我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过JavaScript解决）
  * 视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性

#### 新增input类型

* type="number"：限制用户输入必须为数字类型
* type="tel"：限制用户输入必须为手机号码
* type="search"：搜索框

#### 新增表单属性

* <img src="C:\Users\wenshuyan\AppData\Roaming\Typora\typora-user-images\image-20250403133041256.png" alt="image-20250403133041256" style="zoom:80%;" />
* 可以通过以下设置方式修改placeholder里面的字体颜色：`input::placeholder { color: pink; }`





# Emmet语法

### 快速生成html

* 生成标签：输入标签名 + tab键
* 生成多个相同标签：标签名*n + tab键，快速生成n个该标签
* 父子关系标签：ul > li
* 兄弟关系标签：div + p
* 生成带类/id名的标签：.demo 或者 # two + tab键
* 生成有顺序的类名：自增符号$
* 生成的标签内部写内容：{}

### 快速生成CSS

* w200：width: 200px;

* lh26px：line-height: 26px

### 快速格式化

* shift + alt + f







# CSS

### 选择器

#### 1、基础选择器

* 标签选择器：HTML标签名称做选择器

* 类选择器：html标签中添加class属性，"."定义

  ```css
  .类名 {			// 类前面的"."不能忘记
      属性1:属性值1;
  }
  
  <div class='res'></div> // html标签要使用class属性
  <<div class='res font20'></div> // 多类名，用空格隔开
  ```

* id选择器：html标签中用id属性来设置，"#"定义

  ```css
  #id名 {
      属性1:属性值1;
  }
  <div id='nav'></div>
  // id 属性只能在每个 HTML 文档中出现一次,也只能调用一次
  ```

* 通配符选择器：选取页面所有元素(标签)，"*"定义

  ```css
  * {			
  	margin: 0;
  	padding: 0;
  }
  // 一般不适用，特殊情况才使用，如清除所有的元素标签的内外边距
  ```

#### 2、复合选择器

* 后代选择器(包含选择器)

  ```css
  // 语法：元素1 元素2 { 样式声明 }
  ul li { 样式声明 } // 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可
  ```

* 子元素选择器(子选择器)

  ```css
  // 语法：元素1 > 元素2 { 样式声明 }
  div > p { 样式声明 } // 只选择 div 里面最近一级 p 标签元素
  ```

* 并集选择器：取和

  ```css
  // 语法：元素1,元素2 { 样式声明 }
  ui,div { 样式声明 } // 选择ul和div标签
  ```

* 伪类选择器：用于向某些选择器添加特殊效果

  * 链接伪类选择器：为了保证该选择器生效，必须按照如下的顺序来写

    ```css
    a:link // 选择所有未被访问的标签
    a:visited // 选择所有已被访问的链接
    a:hover // 选择鼠标指针位于其上的链接
    a:active // 选择活动链接(鼠标按下未弹起的链接)
    ```

  * :focus 伪类选择器：选取获得焦点的表单元素，一般都是\<input>

    ```css
    input:focus {
    	background-color:yellow;
    }
    ```

#### 3、新增的选择器

* 属性选择器：根据元素的特定属性来选择元素

  * ``` css
    // E元素 | att属性
    E[att] // 具有att属性的E元素
    E[att="val"] // 具有att属性且等于val值的E元素
    E[att^="val"] // 具有att属性且val开头的E元素
    E[att$="val"] // 具有att属性且val结尾的E元素
    E[att*="val"] // 具有att属性且含有val的E元素
    ```

  * 权重为10

* 结构伪类选择器：根据文档结构来选择元素，通常为父级选择子级

  * ![06-HTML5 和 CSS3 的新特性](images\06-HTML5 和 CSS3 的新特性.png)

  * nth-child(n)：对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配

    * n 可以是数字，选择第 n (1——∞)个子元素， 

    * n 可以是关键字：even 偶数，odd 奇数 

    * n 可以是公式：常见的公式如下 ( 如果n是公式，则从0开始计算，但是第 0 个元素或者超出了元素的个数会被忽略 ) 

      ![06-HTML5 和 CSS3 的新特性2](images\06-HTML5 和 CSS3 的新特性2.png)

  * nth-of-type(n)：对父元素里面指定子元素进行排序选择。 先去匹配E，然后再根据 E 找第n个孩子 

  * 权重为10

* 伪元素选择器：利用CSS创建新标签元素，简化HTML结构。 

  * <img src="images\06-HTML5 和 CSS3 的新特性03.png" alt="06-HTML5 和 CSS3 的新特性03" style="zoom:80%;" />
  * 语法：`element::before { content: ''; } `
  * before 和 after 创建一个元素，但是属于行内元素 
  * 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 
  * before 和 after **必须有 content 属性** 
  * before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素 
  * 伪元素选择器和标签选择器一样，权重为 1 

### 属性

#### 1、字体属性

* font-family：文本字体系列，多个值用" , "分隔

* font-size：字体大小，单位px(像素)

* font-weight：字体粗细，属性值有`normal不加粗；bold加粗；100-900(400等同normal,700等同bold,不跟单位)`

* font-style：文本风格，`normal标准字体；italic斜体`

* 字体复合属性：必须按照下列顺序书写，不能更换顺序，用空格隔开，必须保留size和family属性，否则失效

  ```css
  body {
      font: font-style font-weight font-size/line-height font-family;
  }
  ```

#### 2、文本属性

* color：文本颜色，`预定义颜色(red、green等)；十六进制(#FF0000)；RGB代码(rgb(255,0,0)或rgb(100%,0%,0%))`
* text-align：文本内容水平对齐方式，`left左对齐；right右对齐；center居中对齐`
* text-decoration：装饰文本，`none；underline下划线；overline上划线；line-through删除线`
* text-indent：指定文本的第一行缩进，`10px(像素值)；1em(即一个文字大小)`
* line-height：行间距，`line-height: 26px(整个文本的高度)`

### 引入方式

* 行内样式表（行内式）：直接在html标签中用style属性设定`<div style="color: red; font-size: 12px;"></div>`
* 内部样式表（嵌入式）：css代码放到\<style>标签中
* 外部样式表（链接式）：单独写到css文件中，用\<link>标签引入`<link rel="stylesheet" href="css文件路径">`；rel需要指定为"stylesheet"，表明被链接的是一个样式表文件

### 元素显示模式

**1、块元素**

* 常见的块元素有\<h1>~\<h6>、\<p>、\<div>、\<ul>、\<ol>、\<li>等，其中 \<div> 标签是最典型的块元素
* 特点：独占一行、宽高以及内外边距可以控制、默认宽是父级的100%

**2、行内元素**

* 常见的行内元素有 \<a>、\<strong>、\<b>、\<em>、\<i>、\<del>、\<s>、\<ins>、\<u>、\<span>等，其中\<span> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。
* 特点：一行显示多个、无法直接设置宽高、默认宽取决于内容

**3、行内块元素**

* \<img />、\<input />、\<td>，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。
* 特点：一行显示多个，但会有空白缝隙、默认宽取决于内容、宽高内外边距可控

**4、元素显示模式转换**

* 转换为块元素：`display:block`
* 转换为行内元素：`display:inline`
* 转换为行内块：`display:inline-block`

**5、单行文字垂直居中**

CSS 没有给我们提供文字垂直居中的代码

解决方案: 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中

### 背景

* background-color：元素背景颜色；`默认值transparent(透明)、颜色值`

* background-image：元素背景图像；`默认值none(无图)、url(url)(括号里跟路径，不带引号)`

* background-repeat：背景平铺；`默认值repeat(纵向和横向平铺)、no-repeat(不平铺)、repeat-x(横向平铺)、repeat-y(纵向平铺)`

* background-position：改变图片在背景中的位置；`x y`

  * 参数是方位名词：top | center | bottom | left | center | right，没有前后顺序之分
  * 参数是精确单位：x y；x 居中；百分数| 浮点数和单位标识符
  * 参数是混合单位：精确单位和方位名词混用

* background-attachment：设置背景图像是否固定或者随着页面的其余部分滚动；`scroll(滚动) | fixed(固定)`

* 背景复合写法：background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置；

  ```css
  background: transparent url(image.jpg) repeat-y fixed top ;
  ```

* 背景色半透明：`background: rgba(0, 0, 0, 0.3);`

  * 最后一个参数是 alpha 透明度，取值范围在 0~1之间
  * 可以把0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3);

### 三大特性

#### 1、层叠性

* 定义：相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。
* 层叠行原则：样式冲突的，后面层叠掉前面

#### 2、继承性

* 定义：子标签会继承父标签的某些样式，如文本颜色和字号。

* 行高的继承性

  * ```css
    body {
    	font:12px/1.5 Microsoft YaHei；
    }
    ```

  * 行高可以跟单位也可以不跟单位

  * 如果子元素没有设置行高，则会继承父元素的行高为 1.5；此时子元素的行高是：当前子元素的文字大小 * 1.5

  * body 行高 1.5 这样写法最大的优势就是里面**子元素可以根据自己文字大小自动调整行高**

#### 3、优先级

* 定义：当同一个元素指定多个选择器，就会有优先级的产生。

* | 选择器               | 选择器权重 |
  | -------------------- | ---------- |
  | 继承 / *             | 0，0，0，0 |
  | 元素选择器           | 0，0，0，1 |
  | 类选择器，伪类选择器 | 0，0，1，0 |
  | ID选择器             | 0，1，0，0 |
  | 行内样式 style=""    | 1，0，0，0 |
  | !important 重要的    | ∞无穷大    |

* 注意点

  1. 权重是有4组数字组成,但是不会有进位。
  2. 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推..
  3. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。
  4. 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为
  1000, !important 无穷大.
  5. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。

* 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。

  * div ul li ------> 0,0,0,3
  * .nav ul li ------> 0,0,1,2
  * a:hover -----—> 0,0,1,1
  * .nav a ------> 0,0,1,1

### 盒子模型

#### 1、盒子模型组成

* 定义：就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。
* CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和实际内容
* ![image-20250323193008871](images\image-20250323193008871.png)

#### 2、边框(border)

* 组成：边框宽度(粗细) 边框样式 边框颜色
* 语法：`border : border-width(粗细，px) || border-style(样式) || border-color(颜色)`
* border-style：none(默认值)，solid(单实线)，dashed(虚线)，dotted(点线)
* 简写：`border: 1px solid red; 没有顺序`
* 分开设置：`border-top: 1px solid red; /* 只设定上边框， 其余同理 */`
* border-collapse：浏览器绘制表格边框的方式。它控制相邻单元格的边框`border-collapse:collapse; 相邻边框合并在一起`
* border会影响盒子实际大小，解决：测量盒子大小时不量边框；如果包含边框,则需要 width/height 减去边框宽度

#### 3、内边距(padding)

* 属性：padding-left | padding-right | padding-top | padding-bottom
* 简写
  * `padding: 5px` 1个值，上下左右5px
  * `padding: 5px 10px` 2个值，上下5px，左右10px
  * `padding: 5px 10px 20px` 3个值，上5px，左右10px，下20px
  * `padding: 5px 10px 20px 30px` 4个值，上5px，右10px，下20px，左30px，顺时针
* padding会影响盒子实际大小(额外撑大盒子），解决： width/height 减去多出来的内边距大小即可
* 如果盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小

#### 4、外边距(margin)

* 属性和简写同内边距

* 应用：

  * 让**块级盒子**水平居中：盒子指定宽度(width)，左右外边距设置为auto，如`.header{ width:960px; margin:0 auto;}`

* 外边距合并：使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。

  1. 相邻块元素垂直外边距的合并

     * 上下相邻的两个块元素（兄弟关系）相遇时，上面元素有下外边距，下面的元素有上外边距，则他们之间的垂直间距会被较大者合并。

     * <img src="images\image-20250323194958945.png" alt="image-20250323194958945" style="zoom:50%;" />
     * 解决：尽量只给一个盒子添加margin值

  2. 嵌套块元素垂直外边距的塌陷

     * 两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时**父元素**会塌陷**较大**的外边距值。

     * <img src="images\image-20250323195137469.png" alt="image-20250323195137469" style="zoom: 67%;" />
     * 解决：父元素定义上边框 / 父元素定义上内边距 / 父元素添加overflow:hidden / 浮动、固定、绝对定位

#### 5、清除内外边距

网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。

```css
* {
	padding:0; /* 清除内边距 */
	margin:0; /* 清除外边距 */
}
```

注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了

#### 6、盒模型(box-sizing)

* 属性值
  * `box-sizing: content-box `盒子大小为 width + padding + border （以前默认的）
  * `box-sizing: border-box` 盒子大小为 width，padding和border不会再撑大盒子（前提padding和border不会超过width宽度） 

### CSS3新增样式

#### 1、圆角边框(border-radius)

* 语法：`border-radius: length;`
* 参数值：数值 / 百分比
* 将正方形设置成圆：将数值设为宽高的一半
* 简写：可以跟四个值：左上 | 右上 | 右下 | 左下
* 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius

#### 2、盒子阴影(box-shadow)

* 语法：`box-shadow: h-shadow v-shadow blur spread color inset;`
* 参数值说明：
  * h-shadow 必须项，水平阴影位置，可以负值
  * v-shadow 必须项，垂直阴影位置，可以负值
  * blur 模糊距离
  * spread 阴影的尺寸
  * color 阴影的颜色
  * inset 将外部阴影(outset)改为内部阴影
* 默认的是外阴影(outset), 但是**不可以**写这个单词,否则造成阴影无效
* 盒子阴影**不占用空间**，不会影响其他盒子排列。

#### 3、文字阴影

* 语法：`text-shadow: h-shadow v-shadow blur color;`
* 参数值说明：
  * h-shadow 必须项，水平阴影位置，可以负值
  * v-shadow 必须项，垂直阴影位置，可以负值
  * blur 模糊距离
  * color 阴影的颜色

### 三种定位方式

#### 1、标准流(普通流/文档流)

* 定义：标签按照默认方式排列
* 块级元素独占一行，行内元素从左到右排列

#### 2、浮动(float)

* float：创建浮动框，将其移动到一边，直到左右边缘触及包含块或另一个浮动框边缘
* 语法：`{float: 属性值;}`
* 属性值：none(默认值)不浮动，left向左浮动，right向右浮动
* 浮动特性
  * 浮动元素脱离标准流，不保留原先位置
  * 浮动元素在一行内显示并顶部对齐，贴靠在一起，装不下另起一行
  * 浮动元素具有行内块特性：大小由内容决定，中间没有缝隙
* 常用策略：使用标准流父元素来约束浮动元素，先定义盒子大小，再定义盒子位置

#### 3、清除浮动(clear)

* 原因：父级盒子不方便给高度，但子盒子在浮动情况下不占有位置，所以无法将父级盒子撑开，导致父盒子高度为0，影响下面的标准流盒子

* 本质：清楚浮动元素造成的影响，如果父盒子本身有高度则无需清除浮动

* 清除后，父级会根据浮动的子盒子自动检测高度，便不会影响下面的标准流了

* 语法：`选择器{clear: 属性值;}`

* 属性值：left清除左侧浮动，right清除右侧浮动，both同时清楚左右两侧浮动

* 清除浮动策略：闭合浮动

* 清除浮动方法：

  * 额外标签法(隔墙法)：在浮动元素末添加一个空的标签，如`\<div style="clear:both"> \</div>`，或者其他标签如br等(这个空标签一定是块级元素)

  * overflow：给父级添加overflow属性，将其设置为hidden、auto或scroll，但是无法显示溢出部分

  * :after：给父元素添加:after伪元素

    ```css
    .clearfix:after {
        content: "";
        display: block; // 插入的元素必须是块级 
        height: 0;
        clear: both;
        visibility: hidden;
    }
    .clearfix {
        /* IE6、7 专有 */
        *zoom: 1;
    }
    ```

    

  * 双伪元素：给父元素添加:before和:after双伪元素

    ```css
    .clearfix:before,.clearfix:after {
    	content:"";
    	display:table; // 转换为块级元素并且一行显示 
    }
    .clearfix:after {
    	clear:both;
    }
    .clearfix {
    	*zoom:1;
    }
    ```


#### 4、定位

* 作用：让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。
* 组成：定位 = 定位模式 + 边偏移
* 定位模式(position)：指定元素的定位方式
  * `static`静态定位：无定位(默认)
    * 语法：`选择器 { position: static; }`
    * 特点：按照标准流特性摆放位置，它没有边偏移
  * `relative`相对定位：相对原来位置定位
    * 语法：`选择器 { position: relative; }`
    * 特点：相对自己来移动，它自己原来的位置依旧占有，并且后面的盒子以标准流对待
  * `absolute`绝对定位：相对祖先元素定位
    * 语法：`选择器 { position: absolute; }`
    * 特点：
      * 如果没有**祖先元素**或者**祖先元素没有定位**，则以浏览器为准
      * 以最近一级的有定位祖先为参考
      * 不再占有原先位置(脱标)
  * `fixed`固定定位：固定于浏览器可视区的位置
    * 语法：`选择器 { position: fixed; }`
    * 特点：
      * 以浏览器的可视窗口为参照
      * 跟父元素没有关系，也不随滚动条滚动
      * 不占有原先位置
    * 固定在版心右侧位置算法：
      * 让固定定位盒子left 50%，再margin-left 版心宽度的一半
  * `sticky`粘性定位：相对定位和固定定位的混合
    * 语法：`选择器 { position: sticky; top: 10px; }`
    * 特点：
      * 以浏览器的可视窗口为参照点移动元素（固定定位特点）
      2. 粘性定位占有原先的位置（相对定位特点）
      3. 必须添加 top 、left、right、bottom 其中一个才有效
* 边偏移：决定元素的最终位置，属性为相对父元素边线的距离
  
  * `top:80px`顶端偏移量、`bottom`底部偏移量、`left`左侧偏移量、`right`右侧偏移量
* 子绝父相：子级是绝对定位，父级用相对定位。
  * 子级不占有位置，放在父级任何位置，不影响兄弟盒子
  * 父级加定位限制子盒子位置
  * 父级布局时必须也使用定位，不加定位子级会乱跑，故在四种定位中优先使用相对定位
* 定位叠放次序(z-index)：控制盒子的前后次序
  * 语法：选择器 `{ z-index: 1;} ` 
  * 特点
    * 数值可以是正整数、负整数或 0, 默认是 auto，数值越大，盒子越靠上
    * 如果属性值相同，则按照书写顺序，后来居上
    * 数字后面不能加单位
    * 只有定位的盒子才有 z-index 属性
* 绝对定位盒子居中算法
  * 无法通过`margin:0 auto`水平居中
  * 先 left: 50%，再margin-left: 盒子左移自身宽度一半(通常为负值)
* 定位特殊特性：
  * **行内元素**添加绝对或者固定定位，可以直接设置高度和宽度。(原本无法给宽高)
  * **块级元素**添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。(原本是占据一整行)
* 脱标的盒子不会触发外边距塌陷：浮动元素、绝对定位(固定定位)元素的都不会触发外边距合并的问题。
* 绝对定位（固定定位）会完全压住盒子：
  * 浮动元素会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）
  * 绝对定位（固定定位） 会压住下面标准流所有的内容。

### 属性书写顺序

建议遵循以下顺序：

1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word
4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …

### 元素显示与隐藏

#### 1、显示隐藏(display)

* display：设置一个元素应如何显示。
* 属性：`display: none `隐藏对象；`display：block`转换为块级元素并显示元素
* 特点：display 隐藏元素后，**不再占有原来的位置**。

#### 2、显示隐藏(visibility)

* visibility：指定一个元素应可见还是隐藏。
* 属性：`visibility：visible`元素可视；`visibility：hidden`元素隐藏
* 特点：visibility 隐藏元素后，**继续占有原来的位置**。

#### 3、溢出显示隐藏(overflow)

* overflow ：对溢出元素的部分进行操作
* 属性
  * `visible`不剪切内容也不添加滚动条
  * `hidden`不显示超过对象尺寸的内容，超出的部分隐藏掉
  * `scroll`不管是否超出，总是显示滚动条
  * `auto`超出自动显示滚动条，不超出不显示滚动条

### CSS用户界面样式

* 界面样式：更改用户操作样式，提高用户体验(如：更改鼠标样式、表单轮廓、防止表单拖拽等)

#### 1、鼠标样式(cursor)

* 语法：`li { cursor: pointer; }`
* 属性值：`default(默认)`小白、`pointer`小手、`move`移动、`text`文本、`not-allowed`禁止

#### 2、轮廓线(outline)

* 语法：`input {outline: none; }`
* 表单添加 outline: 0; 或 outline: none; 样式之后，就可以去掉默认的蓝色边框。

#### 3、防止拖拽文本域(resize)

* 语法：`textarea{ resize: none;}`

### 其他

#### 1、精灵图

* 原理：将网页中的一些小背景图像整合到一张大图中 ，服务器只需要一次请求就可以获得全部，提高页面加载速度
* 使用：
  * 将多个小背景整合到一张大图片(sprites 精灵图)中
  * 创建一个盒子，放入精灵图并移动它(background-position)
  * 向上和向左移动为负值，向下和向右为正值
  * 将精灵图通过坐标移动到所需要的图像位置，盒子只显示所需的图标，从而获得该小图标

#### 2、CSS三角

原理：当一个盒子没有宽高，只给它加一定的边框时，且边框的四边颜色都不同时，会有以下效果：

所以，当其中三边都为透明色时，即可获得一个三角形

![image-20250402210512370](images\image-20250402210512370.png)

```css
div {
	width: 0;
	height: 0;
	line-height: 0;
	font-size: 0;
	border: 50px solid transparent;
	border-left-color: pink;
}
```

#### 3、字体图标(iconfont)

1. 字体图标的下载

   * icomoon 字库 http://icomoon.io 
   * 阿里 iconfont 字库 http://www.iconfont.cn/

2. 字体图标的引入

   * 将下载包中的fonts文件夹 放入页面根目录下

   * 在CSS中全局声明字体(引入页面)

   * ```css
     @font-face {
     	font-family: 'icomoon';
     	src: url('fonts/icomoon.eot?7kkyc2');
     	src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
     	url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
     	url('fonts/icomoon.woff?7kkyc2') format('woff'),
     	url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
     	font-weight: normal;
     	font-style: normal;
     }
     ```

   * 在html标签内添加小图标 ` <span> </span>`

   * 给标签定义字体 `span { font-family: "icomoon"; }`(必须与引入@font-face里面的字体名字一致)

3. 字体图标的追加：将下载包里的selection.json重新上传到网页，然后选中新的图标，下载新压缩包并替换原来文件

#### 4、元素对齐方式(vertical-align)

* 使用场景：设置图片或表单和文字的对齐方式，只对行内元素或行内块元素有效
* 语法：`vertical-align : baseline(默认)基线对齐 | top顶端对齐 | middle中间对齐 | bottom底部对齐 `
* 解决图片底部默认有空白缝隙：
  * 原因：行内块元素是和文字的基线对齐
  * 解决
    1. 给图片添加` vertical-align:middle | top| bottom`
    2. 把图片转换为块级元素`display: block;`

#### 5、溢出文字省略号显示

1. 单行文本溢出：

   ```CSS
   /*1. 先强制一行内显示文本*/
    white-space: nowrap; （ 默认 normal 自动换行）
    /*2. 超出的部分隐藏*/
    overflow: hidden;
    /*3. 文字用省略号替代超出的部分*/
    text-overflow: ellipsis;
   ```

2. 多行文本溢出：

   ```css
   overflow: hidden;
   text-overflow: ellipsis;
   /* 弹性伸缩盒子模型显示 */
   display: -webkit-box;
   /* 限制在一个块元素显示的文本的行数 */
   -webkit-line-clamp: 2;
   /* 设置或检索伸缩盒对象的子元素的排列方式 */
   -webkit-box-orient: vertical;
   ```

#### 6、布局技巧

1. margin负值的运用 

   <img src="images\image-20250403131125481.png" alt="image-20250403131125481" style="zoom:67%;" />

   1. 让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 
   2. 鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index）

2. 文字围绕浮动元素

   ![image-20250403131218451](images\image-20250403131218451.png)

   将图片浮动，调节外边距

3. 行内块的巧妙运用

   ![image-20250403131256243](images\image-20250403131256243.png)

   页码在页面中间显示: 

   1. 把这些链接盒子转换为行内块，之后给父级指定 text-align:center; 
   2. 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中

4. CSS三角强化

   ![image-20250403131330130](images\image-20250403131330130.png)

   ```css
   width: 0;
   height: 0;
   border-color: transparent red transparent transparent;
   border-style: solid;
   border-width: 22px 8px 0 0;
   ```

#### 7、css初始化

* 定义：CSS初始化是指重设浏览器的样式。 (也称为CSS reset）

#### 8、滤镜(filter)

* 定义：filter：将模糊或颜色偏移等图形效果应用于元素。 

* 语法：`filter: 函数(); ` 

* ```css
  e { filter: blur(5px); }   // blur模糊处理  数值越大越模糊
  ```

#### 9、calc 函数

* 定义：在声明CSS属性值时执行一些计算
* `width: calc(100% - 80px); `
* 括号里面可以使用 + - *  / 来进行计算。 

#### 10、浏览器私有前缀

1. 私有前缀

   * -moz-：代表 firefox 浏览器私有属性
   * -ms-：代表 ie 浏览器私有属性
   * -webkit-：代表 safari、chrome 私有属性
   * -o-：代表 Opera 私有属性

2. 提倡的写法

   ```css
   -moz-border-radius: 10px;
   -webkit-border-radius: 10px;
   -o-border-radius: 10px;
   border-radius: 10px;
   ```

   

### CSS3 过渡(transition)

* 语法：` transition: 要过渡的属性  花费时间  运动曲线  何时开始; `
* 属性：想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以。 
* 花费时间： 单位是 秒（必须写单位） 比如 0.5s  
* 运动曲线： 默认是 ease （可以省略） 
* 何时开始 ：单位是 秒（必须写单位）可以设置延迟触发时间  默认是 0s  （可以省略）
* ![06-HTML5 和 CSS3 的新特性04](images\06-HTML5 和 CSS3 的新特性04.png)
* 经常和 :hover 一起 搭配使用。

### CSS3 2D转换

#### 1、移动(translate)

* 语法：

  ```css
  transform: translate(x,y); 或者分开写
  transform: translateX(n);
  transform: translateY(n);
  ```

* 定义 2D 转换中的移动，沿着 X 和 Y 轴移动元素

* translate**不会影响**到其他元素的位置

* translate中的百分比单位是**相对于自身元素**的 translate:(50%,50%);

* 对**行内标签**没有效果

#### 2、旋转(rotate)

* 语法：`transfrom: rotate(度数)`
* rotate单位为**度数**， 单位是 deg 如 `rotate(45deg)` 
* 角度为正时，顺时针；负时，为逆时针
* 默认旋转的中心点是元素的中心点

#### 3、转换中心点(transform-origin)

* 语法：`transform-origin: x y;`
* 注意后面的参数 x 和 y 用空格隔开
* x y 默认转换的中心点是元素的中心点 (50% 50%) 
* 还可以给x y 设置 像素 或者 方位名词 （top bottom left right center）

#### 4、缩放(scale)

* 语法：`transform:scale(x,y);`
* 参数中的 x 和 y 用逗号分隔
* transform:scale(1,1) ：宽和高都放大一倍，相对于没有放大
* transform:scale(2,2) ：宽和高都放大了2倍
* transform:scale(2) ：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2) 
* transform:scale(0.5,0.5)：缩小
* sacle缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子

#### 5、综合写法

* 语法：`transform: translate() rotate() scale() ...`
* 其顺序会影响转换的效果。（先旋转会改变坐标轴方向）
* 同时有位移和其他属性的时候，**位移**放到最前

### CSS3 动画(animation)

#### 1、定义动画(keyframes)

* 语法

  ```css
  @keyframes 动画名称 {
  	0%{
  		width:100px;
  	}
  	100%{
  		width:200px;
  	}
  }
  ```

* 动画序列

  * 0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。
  * 在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。
  * 动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数。
  * 用百分比来规定变化发生的时间，或用关键词 "from" 和 "to"，等同于 0% 和 100%。

#### 2、使用动画(animation)

* 语法

  ```css
  div {
  	width: 200px;
  	height: 200px;
  	background-color: aqua;
  	margin: 100px auto;
  	/* 调用动画 */
  	animation-name: 动画名称;
  	/* 持续时间 */
  	animation-duration: 持续时间;
  }
  ```

* 动画常见属性

  |           属性            | 描述                                                         |
  | :-----------------------: | :----------------------------------------------------------- |
  |        @keyframes         | 规定动画。                                                   |
  |         animation         | 所有动画属性的简写属性，除了animation-play-state属性。       |
  |      animation-name       | 规定@keyframes动画的名称。（必须的）                         |
  |    animation-duration     | 规定动画完成一个周期所花费的秒或毫秒，默认是0。（必须的）    |
  | animation-timing-function | 规定动画的速度曲线，默认是“ease”。                           |
  |      animation-delay      | 规定动画何时开始，默认是0。                                  |
  | animation-iteration-count | 规定动画被播放的次数，默认是1，还有infinite                  |
  |    animation-direction    | 规定动画是否在下一周期逆向播放，默认是“normal“,alternate逆播放 |
  |   animation-play-state    | 规定动画是否正在运行或暂停。默认是"running",还有"paused"。   |
  |    animation-fill-mode    | 规定动画结束后状态，保持forwards回到起始backwards            |

* 动画简写属性

  * animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;
  * `animation: myfirst 5s linear 2s infinite alternate;`
  * 简写属性里面不包含 animation-play-state

* 注意点

  * 暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用
  * 想要动画走回来 ，而不是直接跳回来：animation-direction: alternate
  * 盒子动画结束后，停在结束位置：  animation-fill-mode: forwards

* 速度曲线

  * animation-timing-function：规定动画的速度曲线，默认是“ease”

    |     值      | 描述                                           |
    | :---------: | ---------------------------------------------- |
    |   linear    | 动画从头到尾的速度是相同的。匀速               |
    |    ease     | 默认。动画以低速开始，然后加快，在结束前变慢。 |
    |   ease-in   | 动画以低速开始。                               |
    |  ease-out   | 动画以低速结束。                               |
    | ease-in-out | 动画以低速开始和结束。                         |
    |   steps()   | 指定了时间函数中的间隔数量（步长）             |

### CSS3 3D转换

#### 1、3D移动(translate3d)

* transform:translateX(100px)：仅仅是在x轴上移动
* transform:translateY(100px)：仅仅是在Y轴上移动
* transform:translateZ(100px)：仅仅是在Z轴上移动（注意：translateZ一般用px单位）
* transform:translate3d(x,y,z)：其中 x、y、z 分别指要移动的轴的方向的距离
* 因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动

#### 2、透视(perspective)

* 语法：`perspective: 像素`

* 透视让网页产生3D效果
* 透视也称为视距：视距就是人的眼睛到屏幕的距离
* 距离 视觉点 越近成像越大，越远成像越小
* 透视的单位是像素
* 透视写在被观察元素的父盒子上

#### 3、3D旋转(rotate3d)

* 语法
  * transform:rotateX(45deg)：沿着x轴正方向旋转 45度
  * transform:rotateY(45deg) ：沿着y轴正方向旋转 45deg
  * transform:rotateZ(45deg) ：沿着Z轴正方向旋转 45deg
  * transform:rotate3d(x,y,z,deg)： 沿着自定义轴旋转 deg为角度（了解即可）
    * ransform:rotate3d(1,0,0,45deg) 就是沿着x轴旋转 45deg
    * ransform:rotate3d(1,1,0,45deg) 就是沿着对角线旋转 45deg
* 左手准则：左手拇指指向的为轴，四指弯曲的方向为该轴的旋转正方向

#### 4、3D呈现(transfrom-style)

* 作用：控制子元素是否开启三维立体环境
* 属性：`transform-style: flat(默认)子元素不开启3d立体空间 / preserve-3d(子元素开启立体空间)`
* 代码写给父级，但是影响的是子盒子







# JS

### JavaScript介绍

#### 书写位置

##### 1、内部JavaScript

* 直接写在html文件里，用script标签包住
* 规范：将script标签写载HTML页面底部(\</body>上面)
* 原因：浏览器会按顺序加载代码，若先加载JavaScript，那么可能会由于HTML尚未被加载而失效，因此将JavaScript代码放在HTML页面底部附近是最好的策略

##### 2、外部JavaScript

* 写在以.js结尾的文件里
* 通过 `<script src="my.js></script>"` 引入html页面中
* 注意：script标签中间无需写代码，否则会被忽略！

##### 3、内联JavaScript

* 写在标签内部
* 语法：`<button onclick="alert('是wsy！')">努力学前端的是谁呀</button>`

#### 结束符

* 分号 ；
* 可写可不写，但要么全写要么全不写，根据团队统一

#### 输入输出语法

##### 1、输出语法

1. 语法1
   * `document.write('要输出的内容')`
   * 作用：向body内输出内容
   * 注意：如果输出的内容写的是标签，也会被解析成网页元素
2.  语法2
   * `alert('警告你喔')`
   * 作用：页面弹出警告对话框
3. 语法3
   * `console.log('控制台打印')`
   * 作用：控制台输出语法，程序员调试使用

##### 2、输入语法

* `prompt('请输入您的姓名')`
* 作用：显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字
* <img src="\images\js\1.png" alt="1" style="zoom:67%;" />

### 基础语法

#### 变量

* 声明：`let 变量名`
  * 可以一行声明多个变量，但更推荐一行声明一个
* 命名规则：
  * 关键字：let、var等
  * 可以用下划线、字母、数字、$组成，但数字不能开头
  * 严格区分大小写
  * 命名遵守小驼峰命名法

* let 和 var 区别： var是旧版js使用的，let是var的修复版，故统一使用let即可
* 数组：`let 数组名 = [数据1，数据2，...，数据n]`
  * 数据可以存储任意类型的数据
  * 数据名.length：数组长度

#### 常量

* 声明：`const 变量 = 值`
  * 不可重新赋值，必须初始化

#### 数据类型

* 数据类型
  * 基本数据类型：number | string | boolean | undefined(未定义型) | null
  * 引用数据类型：object
  * JS 是弱数据类型，同py相似
* 数据类型介绍
  * NaN：代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。任何对 NaN 的操作都会返回 NaN 
  * String：推荐使用单引号包裹
    * 模板字符串：用反引号引起来的字符串，可以在内容里用${}来包住变量
    * ``document.write(`大家好，我叫${name}，今年${age}岁`)``
  * undefined：只声明未赋值的变量
    * undefined 和 null 区别：undefined表示未赋值，null表示赋值了但内容为空
* 检测数据类型
  * typeof关键字检查
  * 语法
    * 作为运算符：`typeof x`(常用写法)
    * 作为函数：`typeof(x)`

#### 类型转换

* 原因：表单、prompt获取的数据默认是字符串类型
* 隐式转换
  * \+ 号两边只要有一个是字符串，都会把另外一个转成字符串
  * 除了+以外的算术运算符 比如 -  *  /  等都会把数据转成数字类型
  * `let x = +字符串` 这种写法可以让字符串转换成数字型，但若该字符串不是数字会产生NaN
* 显示转换
  * 数字型
    * Number(数据)：若有非数字，会转换失败，结果为NaN
    * parseInt(数据)
    * parseFloat(数据)
  * 字符型
    * String(数据)
    * 变量.toString(进制)

#### 运算符

* 比较运算符
  * ==：左右值是否相等
  * ===：左右值以及类型是否都相等(全等)
  * !==：左右两边是否不全等
  * 不同类型之间比较会发生隐式转换，故使用===会更好

#### 数组

##### 1、添加新的数据

* 数组.push( )：将一个或多个元素添加到数组的**末尾**，并返回该数组的新长度
* 语法：`arr.push(元素1,...,元素n)`
* arr.unshift( )：将一个或多个元素添加到数组的**开头**，并返回该数组的新长度

##### 2、删除数组中的数据

* 数组.pop( )：从数组中删除最后一个元素，并返回该元素的值
* 数组.shift( )：从数组中删除第一个元素，并返回该元素的值
* 数组.splice( )：删除指定元素
* 语法：`arr.splice(start,count)` count可选，省略则默认从start删到最后

##### 3、数组排序

* 数组.sort() 

* ```js
  let arr = [4, 2, 5, 1, 3]
  // 1.升序排列写法
  arr.sort(function (a, b) {
  	return a - b
  })
  console.log(arr)  // [1, 2, 3, 4, 5]
  // 降序排列写法
  arr.sort(function (a, b) {
  	return b - a
  })
  console.log(arr)  // [5, 4, 3, 2, 1]
  ```

##### 4、数组中map方法

* map()：迭代数组

* 语法：

  ```js
  const arr = ['pink','red','blue']
  arr.map(function(){
      // 方法体，会依次遍历数组的每一个数据
  })
  ```

##### 5、数组中join方法

* join() 方法用于把数组中的所有元素转换一个字符串

* 语法：

  ```js
  const arr = ['pink','red','blue']
  let str = arr.join(' ') // pink red blue
  ```

* 参数：数组元素是通过参数里面指定的分隔符进行分隔的，默认为逗号

##### 6、遍历数组forEach方法

forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数

```js
数组.forEach(function(当前数组元素，当前元素索引号){
    // 函数体
})
```

##### 7、筛选数组filter方法

 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素

```js
数组.filter(function(currentValue, index){
    return 筛选条件
})
```

* 参数：currentValue 必须写， index 可选
* 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组

#### 函数

* 声明：

  ```js
  function 函数名(参数列表) {
      函数体
      retrun 数据
  }
  ```

* 命名

  * 小驼峰命名法
  * 前缀应该为动词

* 参数默认值

  * ``` js
    function getSum(x = 0, y = 0){
        document.write(x + y)
    }
    getSum() // 结果是0，而不是NaN
    getSum(1，2) // 3
    ```

  * 如果没有默认值，在调用的时候用户没有输入实参，那么可能会返回NaN，故这种写法可以让其返回0，更加严谨

* 逻辑中断

  * ```js
    x = x || 0 // 如果x没有赋值，则可以用0赋值给x
    var dpr = window.devicePixelRatio || 1 // 获取当前设备，若获取不到则默认取值1
    ```

#### 对象

* 声明

  * `let 对象名 = {} ` // {}是对象字面量，常用
  * `let 对象名 = new Object()`

* 使用

  ```js
  let 对象名 = {
      属性名: 属性值,
      方法名: 函数
  }
  如：
  let obj = {
      uname: 'wsy',
      age: 18,
      now: '学前端'
  }
  ```

* 属性增加：`对象名.新属性 = 新值`

* 属性删减：`delete 对象名.属性`

* 属性查找

  ```js
  let person = {
      'user-name': 'wsy',
      age: 18,
      now: '学前端'
  }
  console.log(person.user-name) // NaN
  console.log(person['user-name']) // wsy
  ```

  * `对象[‘属性’]`  方式， 单引号和双引号都可以
  * [ ]语法里面的值如果不添加引号 默认会当成变量解析

* 对象中的方法

  ```js
  let person = {
      name: 'wsy',
      sayHi: function() {
          document.write('你好呀~')
      }
  }
  person.sayHi()
  ```

* 遍历对象

  ```js
  let person = {
      name: 'wsy',
      age: 18,
      now: '学前端'
  }
  for (let k in person) {
      console.log(k) // 打印属性名
      console.log(obj[k]) // 打印属性值
  }
  ```

  * 由于k是一个变量，故必须使用[ ]语法来解析

* 内置对象
  * Math：https://www.w3school.com.cn/jsref/jsref_obj_math.asp
    *  Math.random()  随机数函数， 返回一个0 - 1之间，并且包括0不包括1的随机小数  [0, 1）
    * 生成0-10的随机数：`Math.floor(Math.random() * (10 + 1))`
    * 生成N-M之间的随机数：`Math.floor(Math.random() * (M - N + 1)) + N`

### DOM

#### DOM定义

##### 1、DOM

DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API (浏览器提供的一套专门用来**操作网页内容**的功能)

##### 2、DOM树

将HTML文档以树状结构直观的表现出来，该结构称为文档树或DOM树

##### 3、DOM对象

浏览器根据html标签生成的JS对象，其核心即把内容当对象处理

* document对象：DOM提供的一个对象，用来访问和操作网页内容
* 网页所有内容都在document里面

#### 获取DOM对象

##### 1、根据CSS选择器获取DOM元素

1. 选择匹配的第一个元素
   * 语法：`document.querySelector('css选择器')`
   * 返回值：CSS选择器匹配的第一个元素,一个 HTMLElement对象。如果没有匹配到，则返回null。
2. 选择匹配的多个元素
   * 语法：`document.querySelectorAll('css选择器')`
   * 返回值：CSS选择器匹配的 NodeList 对象集合
   * 该对象是一个伪数组，有长度索引但没有pop、push等方法；只能通过遍历得到每个元素
   * 注意：哪怕只有一个元素，通过querySelectAll() 获取过来的也是一个伪数组，里面只有一个元素而已

##### 2、其他获取DOM元素方法

```js
document.getElementById('nav') // 根据id获取一个元素
document.getElementsByTagName('div') // 根据标签获取一类元素
document.getElementsByClassName('w') // 根据类名获取元素
```

#### 操作DOM对象元素

##### 1、操作元素内容

1. 元素.innerText  属性
   * 将文本内容添加/修改到任意标签位置
   * 显示纯文本，**不解析标签**

2. 元素.innerHTML  属性
   * 将文本内容添加/更新到任意标签位置
   * **会解析标签**，多标签建议使用**模板字符串**

##### 2、操作元素属性

1. 操作元素常用属性(html标签属性)

   	* 通过js 设置/修改标签元素属性
      	* 语法：`对象.属性 = 值`

2. 操作元素样式属性(标签的css属性)

   * 修改标签元素的样式属性，如修改颜色样式、移动图片位置

   1. 通过style属性操作CSS：`对象.style.样式属性 = 值`

      * 修改样式通过style属性引出
      * 如果属性有-连接符，需要转换为小驼峰命名法
      * 赋值的时候，需要的时候不要忘记加css单位

   2. 操作类名(className)操作CSS：`元素.className = 'active'`

      * 由于class是关键字, 所以使用className去代替
      * className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名

   3. 通过classList操作类控制CSS

      ```js
      元素.classList.add('类名') // 追加一个类
      元素.classList.remove('类名') // 删除一个类
      元素.classList.toggle('类名') // 切换一个类
      ```

3. 操作表单元素属性

    1. 设置表单元素属性：`DOM对象.属性名`，如：`表单元素.value = '用户名'`

    2.  表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示

        * 设置为true 代表添加该属性，设置为false 代表移除了该属性

        * 如：disabled、checked、selected

4. 自定义属性

    1. 在html5中推出来了专门的data-自定义属性
    2. 在标签上一律以`data-`开头
    3. 在DOM对象上一律以 dataset对象 方式获取
        1. 设置：`<div class="box" data-id="10"></div>`
        2. 获取：`console.log(box.dataset.id)`

#### 定时器--间歇函数

* 开启定时器
  * 语法：`setInterval(函数名, 间隔时间)`
  * 作用：每隔一段时间调用这个函数，间隔时间单位是毫秒ms
  * 注意：函数名不需要加括号；定时器返回值为id数字
* 关闭定时器
  * 语法：`clearInterval(定时器返回值)`
  * 如果需要再次开启定时器，则需要重新调用`setInterval(函数名, 间隔时间)`，同时该返回值会更新，故保存返回值需要用let

### DOM事件基础

#### 事件监听(绑定)

* 语法：`元素对象.addEventListener('事件类型',要执行的函数)`
* 事件监听三要素：
  * 事件源： 那个dom元素被事件触发了，要获取dom元素 
  * 事件类型： 用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等
  * 事件调用的函数： 要做什么事
* 注意：事件类型要加引号
* 事件监听版本：
  * DOM L0 
         事件源.on事件 = function() { }
  * DOM L2 
         事件源.addEventListener(事件， 事件处理函数)
  * 区别：
         on方式会被覆盖，addEventListener方式可绑定多次，拥有事件更多特性，推荐使用

#### 事件类型

* 鼠标事件
  * click 鼠标点击
  * mouseenter 鼠标经过
  * mouseleave 鼠标离开
* 表单获得光标
  * focus 获得焦点
  * blur 失去焦点
* 键盘触发
  * Keydown 键盘按下触发
  * Keyup 键盘抬起触发
* 表单输入触发
  * input 用户输入事件

#### 事件对象

* 获得事件对象

  * 回调函数的第一个参数就是事件对象，一般命名为event、ev、e

  * 语法

    ```js
    元素.addEventListener('click', function(e){ // e则为事件对象
        
    })
    ```

* 事件对象常用属性

  * type 获取当前事件类型
  * clientX/clientY 获取光标相对于浏览器可见窗口左上角的位置
  * offsetX/offsetY 获得光标相对于当前DOM元素左上角的位置
  * key 用户按下的键盘键的值，不提倡使用keyCode

#### 环境对象

* 环境对象：指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境
* 直接调用函数，其实相当于是 window.函数，所以 this 指代 window

#### 回调函数

当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数

### DOM事件进阶

#### 事件流

##### 1、事件流的两个阶段

* 事件流：指的是事件完整执行过程中的流动路径
* 两个阶段
  * 捕获阶段：从父级到子级
  * 冒泡阶段：从子级到父级

##### 2、事件捕获

* 概念：从DOM的根元素开始去执行对应的事件 (从外到里)
* 语法：`DOM.addEventListener(事件类型,事件处理函数,是否使用捕获机制)`
* 说明
  * addEventListener第三个参数传入 true 代表是捕获阶段触发（很少使用）
  * 若传入false代表冒泡阶段触发，默认就是false
  * 若是用 L0 事件监听，则只有冒泡阶段，没有捕获

##### 3、事件冒泡

* 概念：当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡
* L2事件监听第三个参数是 false，或者默认都是冒泡（故事件冒泡是默认存在的）

##### 4、阻止冒泡

* 原因：冒泡模式容易影响到父级元素，通过阻止冒泡来阻止事件冒泡

* 阻止冒泡语法：`事件对象.stopPropagation()`（此方法可以阻断事件流动传播，捕获阶段也有效）

* 阻止默认行为发生：`e.preventDefault()`

  ```js
  元素.addEventListener('click', function(e){
      e.preventDefault()
  })
  ```

##### 5、解绑事件

* L0事件解绑：

  ```js
  btn.onclick = function(){
      alert('点击')
  }
  btn.onclick = null // 解绑（类似于赋值操作）
  ```

* L2事件监听解绑：`removeEventListener(事件类型, 事件处理函数,  [获取捕获或者冒泡阶段])`

  ```js
  function fu(){
      alert('点击')
  }
  btn.addEventListener('click',fn) // 绑定事件
  btn.removeEventListener('click',fn) // 解绑事件
  ```

##### 6、鼠标经过事件区别

* mouseover 和 mouseout 会有冒泡效果
* mouseenter 和 mouseleave 没有冒泡效果

##### 7、两种注册事件区别

* 传统on注册(L0)
  * 同一个对象,后面注册的事件会覆盖前面注册(同一个事件)
  * 直接使用null覆盖偶就可以实现事件的解绑
  * 都是冒泡阶段执行的
* 事件监听注册（L2）
  * 语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获)
  * 后面注册的事件不会覆盖前面注册的事件(同一个事件)
  * 可以通过第三个参数去确定是在冒泡或者捕获阶段执行
  * 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)
  * 匿名函数无法被解绑

#### 事件委托

* 原理：利用事件冒泡的特点，给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件

* 实现：事件对象.target. tagName 可以获得真正触发事件的元素

* 如

  ```js
  const ul = document.querySelector('ul')
  ul.addEventListener('click',function(e){
      if (e.target.tagName === 'LI'){ // 可以先F12检查看tagName是什么
          this.style.color = 'pink'
      }
  })
  ```

#### 其他事件

##### 1、页面加载事件

* **load事件**

  * 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件

  * 监听页面所有资源加载完毕：给window添加load事件

  * ```js
    // 页面加载事件
    window.addEventListener('load',function(){
        // 执行的操作
    })
    ```

  * 不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件

* **DOMContentLoaded事件**

  * 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载

  * 监听页面DOM加载完毕：给document添加 DOMContentLoaded 事件

  * ```js
    document.addEventListener('DOMContentLoaded',function(){
        // 执行的操作
    })
    ```

##### 2、元素滚动事件

* **scroll事件**

  * 滚动条在滚动的时候持续触发的事件

  * 监听整个页面滚动：给 window 或 document 添加 scroll 事件

  * ```js
    window.addEventListener('scroll',function(){
        // 执行的操作
    })
    ```

  * 监听某个元素的内部滚动直接给某个元素加即可

* 获取位置

  * scrollLeft和scrollTop （属性）

    * 获取被卷去的大小
    * 获取元素内容往左、往上滚出去看不到的距离
    * 这两个值是可读写的（可直接赋值）

  * 尽量在scroll事件里面获取被卷去的距离

  * 检测页面滚动的距离：

  * ```js
    window.addEventListener('scroll',function(){
        let n = document.documentElement.scrollTop
    })
    ```

  * document.documentElement   HTML 文档返回对象为HTML元素

##### 3、页面尺寸事件

* resize事件

  * 会在窗口尺寸改变的时候触发事件

  * 检测屏幕宽度：

  * ```js
    window.addEventListener('resize',function(){
        let w = document.documentElement.clientWidth
    })
    ```

* 获取元素宽高

  * 获取元素的可见部分宽高（不包含边框，margin，滚动条等）
  * clientWidth和clientHeight

#### 元素尺寸与位置

##### 1、尺寸

* 获取元素宽高

  * offsetWidth和offsetHeight (只读属性)
  * 元素的自身宽高、包含元素自身设置的宽高、padding、border
  * 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0

* 获取元素位置

  1. offsetLeft和offsetTop
     * 只读属性
     * 获取元素距离自己定位父级元素的左、上距离

  2. element.getBoundingClientRect()
     * 返回元素的大小及其相对于视口的位置

### DOM节点

#### 日期对象

##### 1、实例化

* 获得当前时间：`const date = new Date()`
* 获得指定时间：`const date = new Date('2008-8-8')`

##### 2、日期对象方法

| 方法          | 作用               | 说明                 |
| ------------- | ------------------ | -------------------- |
| getFullYear() | 获得年份           | 获取四位年份         |
| getMonth()    | 获得月份           | 取值为 0 ~ 11        |
| getDate()     | 获取月份中的每一天 | 不同月份取值也不相同 |
| getDay()      | 获取星期           | 取值为 0 ~ 6         |
| getHours()    | 获取小时           | 取值为 0 ~ 23        |
| getMinutes()  | 获取分钟           | 取值为 0 ~ 59        |
| getSeconds()  | 获取秒             | 取值为 0 ~ 59        |

##### 3、时间戳

获得时间戳的三种方式

* 使用getTime()方法

  ```js
  const date = new Date()
  console.log(date.getTime())
  ```

* 简写 + new Date()：`console.log(+new Date())`(因为new Date() 得到的是一串字符串，故使用+将其转换成整型)

* 使用Date.now()：`console.log(Date.now())`( 但是只能得到当前的时间戳， 而前面两种可以返回指定时间的时间戳)

#### 节点操作

##### 1、DOM节点

* DOM节点： DOM树里每一个内容都称之为节点
* 节点类型：
  * 元素节点：所有的标签 比如 body、 div；html 是根节点
  * 属性节点：所有的属性 比如 href
  * 文本节点：所有的文本 
  * 其他

##### 2、查找节点

* 查找父节点：`子元素.parentNode`（返回最近一级的父节点 找不到返回为null）
* 查找子节点：`父元素.children`
  * 获得所有子节点、包括文本节点（空格、换行）、注释节点等
  * 返回的还是一个伪数组
* 查找兄弟节点：
  * 查找下一个兄弟节点：`元素.nextElementSibling`
  * 查找上一个兄弟节点：`元素.previousElementSibling`

##### 3、增加节点

* 创建节点：`document.createElement('标签名')`
* 追加节点：
  * 插入到父元素的最后一个子元素：`父元素.appendChild(要插入的元素)`
  * 插入到父元素中某个子元素的前面：`父元素.insertBefore(要插入的元素，在哪个元素前面)`
* 克隆节点：`元素.cloneNode(布尔值)`
  * 若为true，则代表克隆时会包含后代节点一起克隆(深克隆)
  * 若为false，则代表克隆时不包含后代节点，默认为false(浅克隆)

##### 4、删除节点

* 必须通过父元素删除：`父元素.removeChild(要删除的元素)`
  * 如不存在父子关系则删除不成功
  * 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点

#### M端事件

* M端即移动端
* 触屏事件touch：
  * touchstart：手指触摸到一个DOM元素时触发
  * touchmove：在DOM元素上滑动时触发
  * touchend：在DOM元素上移开时触发

#### JS插件

* 官网： https://www.swiper.com.cn/ 

### BOM操作

#### Window对象

##### 1、BOM

* BOM：浏览器对象模型
* window对象是一个全局对象，也可以说是JavaScript中的顶级对象
* 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。
* 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法
* window对象下的属性和方法调用的时候可以省略window

##### 2、定时器——延迟函数

* 语法：`setTimeout(回调函数，等待的毫秒数)`(setTimeout 仅仅只执行一次)

* 清除延时函数

  ```js
  let timer = setTimeout()
  clearTimeout(timer)
  ```

* 延时器需要等待,所以后面的代码先执行

* 每一次调用延时器都会产生一个新的延时器

##### 3、JS执行机制

* 同步任务：同步任务都在主线程上执行，形成一个执行栈。

* 异步任务：通过回调函数实现的，异步任务有三种类型

  * 普通事件，如 click、resize 等
  * 资源加载，如 load、error 等
  * 定时器，包括 setInterval、setTimeout 等

  异步任务相关添加到任务队列中（任务队列也称为消息队列）。

* 执行顺序：

  * 先执行执行栈中的同步任务。
  * 异步任务放入任务队列中。
  *  一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
  * ![2](images\js\2.png)
  * 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop )

##### 4、location对象

* location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分

* 常用属性：
  * href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转
  * search 属性获取地址中携带的参数，符号 ？后面部分
  * hash 属性获取地址中的啥希值，符号 # 后面部分
  * reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新
* 语法：`location.属性`

##### 5、navigator对象

* navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

* 常用属性

  * 通过 userAgent 检测浏览器的版本及平台

  * ```js
    // 检测 userAgent（浏览器信息）
    !(function () {
    	const userAgent = navigator.userAgent
    	// 验证是否为Android或iPhone
    	const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/)
    	const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
    	// 如果是Android或iPhone，则跳转至移动站点
    	if (android || iphone) {
    		location.href = 'http://m.itcast.cn'
    	}
    })()
    ```

* 语法：`navigator.属性`

##### 6、histroy对象

* history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等
* 常用方法
  * back()  后退
  * forward()  前进
  * go(参数)  参数为1：前进，参数为-1：后退

#### 本地存储

##### 1、localStorage

* 作用：可以将数据永久存储在本地(用户的电脑), 除非手动删除，否则关闭页面也会存在
* 特性：
  * 可以多窗口（页面）共享（同一浏览器可以共享）
  * 以键值对的形式存储使用
* 语法：
  * 存储数据：`localStorage.setItem(key, value)`
  * 获取数据：`localStorage.getItem(key)`
  * 删除数据：`localStorage.removeItem(key)`

##### 2、sessionStorage

* 特性：
  * 生命周期为关闭浏览器窗口(同一个会话里)
  * 在同一个窗口(页面)下数据可以共享
  * 以键值对的形式存储使用
  * 用法跟localStorage 基本相同

##### 3、存储复杂数据类型

* 将复杂数据类型转换成JSON字符串,在存储到本地
  * 语法：`JSON.stringify(复杂数据类型)`
* 把取出来的字符串转换为对象
  * 语法：`JSON.parse(JSON字符串)`

### 正则表达式

##### 1、语法

* 定义正则表达式：`const 变量 = /表达式/`
* 判断是否有符合规则的字符串：test() 方法   查看正则表达式与指定的字符串是否匹配
  * `regObj.test(被检测字符串)` // 匹配为true，不匹配false
* 检索（查找）符合规则的字符串：exec() 方法 在一个指定字符串中执行一个搜索匹配
  * `regObj.exec(被检测字符串)` // 匹配返回一个数组，否则返回null

##### 2、元字符

* 边界符：提示字符所处的位置

  * ^     匹配行首的文本(以谁开始)
  * $     匹配行尾的文本(以谁结束)
  * 如果两者结合，则是精确匹配

* 量词：设定某个模式出现的次数

  * | 量词  | 说明                   |
    | ----- | ---------------------- |
    | *     | 重复零次或更多次   >=0 |
    | +     | 重复零次或更多次   >=0 |
    | ？    | 重复零次或一次       0 |
    | {n}   | 重复n次                |
    | {n,}  | 重复n次或更多次        |
    | {n,m} | 重复n到m次             |

* 字符类

  * \[ ]   匹配字符集合

    * 检测的字符串只要包含[ ]中任意一个字符，都返回 true 。
    * 使用连字符 - 表示一个范围：`[a-zA-Z]`表示大小写都可以
    *  里面加上 ^  取反符号 :`[^a-z]` 匹配除了小写字母以外的字符

  * . (点)   匹配除换行符之外的任何单个字符

  * 预定义：某些常见模式的简写方式。

    * | 预定类 | 说明                                                       |
      | ------ | ---------------------------------------------------------- |
      | \d     | 匹配0-9任意数字，相当于[0-9]                               |
      | \D     | 匹配所有0-9以外的字符，相当于\[^0-9]                       |
      | \w     | 匹配任意字母、数字、下划线，相当于[A-Za-z0-9_]             |
      | \W     | 除了所有字母、数字、下划线以外的字符，相当于\[^A-Za-z0-9_] |
      | \s     | 匹配空格(包括换行符、制表符、空格符)，相当于[\t\r\n\v\f]   |
      | \S     | 匹配非空格的字符，相当于\[^\t\r\n\v\f]                     |

  * 修饰符：约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等

    * 语法：`/表达式/修饰符`
    * i：单词 ignore 的缩写，正则匹配时字母不区分大小写
    * g：单词 global 的缩写，匹配所有满足正则表达式的结果
    * 如：`/a/i` 

  * replace替换

    * 语法：`字符串.replace(/正则表达式/,'替换的文本')`
    * 由于replace默认只替换符合规则的第一个，若要替换所有，可以带上修饰符g
    * 如：`字符串.replace(/a/ig,'替换的文本')`

### 作用域

#### 局部作用域

##### 1、函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问

##### 2、块作用域

使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。

*  let、const 声明的变量会产生块作用域，var 不会产生块作用域
* 故var会被外部访问到

#### 全局作用域

\<script> 标签 和 .js 文件 的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。全局作用域中声明的变量，任何其它作用域都可以被访问

* 为 window 对象动态添加的属性默认也是全局的，不推荐！
* 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！
* 尽可能少的声明全局变量，防止全局变量被污染

#### 作用域链

作用域链本质上是底层的**变量查找机制。**

* 在函数被执行时，会优先查找当前函数作用域中查找变量
* 如果当前作用域查找不到则会依次**逐级查找父级作用域**直到全局作用域

#### JS垃圾回收机制

* 垃圾回收机制(Garbage Collection)  简称 GC

* 不再用到的内存，没有及时释放，就叫做内存泄漏

* 内存生命周期

  * 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
  * 内存使用：即读写内存，也就是使用变量、函数等 
  * 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 
    *  全局变量一般不会回收(关闭页面回收)；
    *  一般情况下局部变量的值, 不用了, 会被自动回收掉

* 算法说明

  * 栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
  * 堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。

* 引用计数

  * IE采用的引用计数算法, 定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象
  * 算法：
    1. 跟踪记录被引用的次数
    2. 如果被引用了一次，那么就记录次数1,多次引用会累加 ++
    3. 如果减少一个引用就减1
    4. 如果引用次数是0 ，则释放内存

  * 问题
    * 嵌套引用(循环引用) ：如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 

* 标记清除法

  * 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 
  * 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。
  * 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 

#### 闭包

一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

```js
function outer(){
    let i = 1
    function fn(){
        console.log(i)
    }
    return fn
}
const fun = outer()
fun() // 外层函数使用内部函数的变量
```

这样实现了数据私有，无法直接修改参数

问题：可能引起内存泄漏

#### 变量提升

变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量）

* 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为 undefined
3. let/const 声明的变量不存在变量提升
4. 变量提升出现在相同作用域当中
5. 实际开发中推荐先声明再访问变量

### 函数进阶

#### 函数提升

函数提升与变量提升比较类似，是指函数在声明之前即可被调用。

* 函数提升能够使函数的声明调用更灵活
2. 函数表达式不存在提升的现象
3. 函数提升出现在相同作用域当中

```js
// 函数提升
foo()
function foo(){
    console.log('声明之前即被调用')
}

// 不存在提升现象
bar()
var bar = function(){
    console.log('函数表达式不存在提升现象')
}
```

#### 函数参数

##### 1、动态参数

arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参

* arguments 是一个**伪数组**，只存在于函数中
2. arguments 的作用是动态获取函数的实参
3. 可以通过for循环依次得到传递过来的实参

##### 2、剩余参数

 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参，该实参是个真数组

```js
function config(baseURL, ...other){}
```

##### 3、展开运算符

展开运算符(…),将一个数组进行展开

```js
const arr = [1,5,3,8,2]
console.log(...arr) // 1 5 3 8 2
```

#### 箭头函数

##### 1、基本语法

```js
// 普通函数
const fn = function(){
    console.log('我是普通函数')
}

// 箭头函数
const fn = () => {
    console.log('我是箭头函数')
}
```

只有一个参数可以省略小括号

```js
// 普通函数
const fn = function(x){
    return x + x
}

// 箭头函数
const fn = x => {
    return x + x
}
```

如果函数体只有一行代码，可以写到一行上，并且无需写 return 直接返回值

```js
// 普通函数
const fn = function(x, y){
    return x + y
}

// 箭头函数
const fn = (x, y) => x + y
```

加括号的函数体返回对象字面量表达式

```js
const fn = uname => ({uname: uname})
```

##### 2、箭头函数参数

* 普通函数有arguments 动态参数
2. 箭头函数没有 arguments 动态参数，但是有 剩余参数 ..args

```js
const getSum = (...args) => {
    // 函数体
}
```

##### 3、箭头函数this

箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。

在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数

```js
const btn = document.querySelector('.btn')

// 箭头函数此时this指向window
btn.addEventListener('click',() => {
    console.log(this)
})

// 普通函数此时this指向DOM对象
btn.addEventListener('click',function(){
	console.log(this)
})
```

#### 解构赋值

##### 1、数组解构

语法

* 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作 

```js
// 批量赋值
// 方式一
const arr = [1,2,3]
const [a,b,c] = arr
// 方式二
const [a,b,c] = [1,2,3]

// 交换变量
let a = 1
let b = 2; // 必须要有分号，同立即执行函数一样
[b,a] = [a,b]

// 变量多于单元值
const [a,b,c] = [1,2]
// a = 1; b = 2; c = undefined

// 变量少于单元值
const [a,b] = [1,2,3]
// a = 1; b = 2

// 剩余参数解决变量少问题
const [a,b,...arr] = [1,2,3,4]
// a = 1; b = 2; arr = [3,4]

// 防止有undefined传递单元值的情况，可以设置默认值
const [a = 0, b = 0] = [1]
// a = 1; b = 0

//按需导入，忽略某些返回值
const [a,b, ,d] = [1,2,3,4]
// a = 1; b = 2; d = 4

// 支持多维数组的结构
const [a, [b, c]] = [1, [2, 3]]
// a = 1; b = 2; c = 3
```

##### 2、对象解构

语法：

* 赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给与属性名相同的变量
* 注意解构的变量名不要和外面的变量名冲突否则报错
* 对象中找不到与变量名一致的属性时变量值为 undefined

```js
// 普通对象
const user = {
    name: '小明',
    age: 18
}
// 批量赋值，注意变量名一定与对象属性名一致
const {name, age} = user
// name = '小明'; age = 18

// 可以从一个对象中提取变量并同时修改新的变量名
const {name: uname, age} = user
// uname = '小明'; age = 18

// 对象数组
const user = [
    {
    	name: '小明',
    	age: 18
	}
]
const [{name, age}] = user

// 多级对象解构
 const pig = {
      name: '佩奇',
      family: {
        mother: '猪妈妈',
        father: '猪爸爸',
        sister: '乔治'
      },
      age: 6
}
const {name, family: {mother, father, sister}} = pig
```

### 构造函数

#### 深入对象

##### 1、创建对象三种方式

```js
// 利用对象字面量创建对象
const o = {
    name: '小温'
}

// 利用new Object 创建对象
const o = new Object({ name: '小温'})

// 利用构造函数创建对象
function People(name){
    this.name = name
}
const Wen = new People('小温')
```

* 约定：命名以大写字母开头，只能由 "new" 操作符来执行。
* 实例成员：通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。
* 静态成员：构造函数的属性和方法被称为静态成员

#### 内置构造函数

##### 1、Object

* Object.keys(对象)：获取对象中所有属性（键），返回数组

* Object.values(对象)：获取对象中所有属性值，返回数组

* Object. assign(空对象，对象)：常用于对象拷贝

  * 应用：给对象添加属性

  * ```js
    const o = {name = '小温'}
    Object.assign(o,{age = 18})
    // o = {name = '小温', age = 18}
    ```

##### 2、Array

| 方法    | 作用     | 说明                                                         |
| ------- | -------- | ------------------------------------------------------------ |
| forEach | 遍历数组 | 不返回，用于不改变值，经常用于查找打印输出值                 |
| filter  | 过滤数组 | 筛选数组元素，并生成新数组                                   |
| map     | 迭代数组 | 返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据 |
| reduce  | 累计器   | 返回函数累计处理的结果，经常用于求和等                       |

* reduce：`arr.reduce(function(累计值, 当前元素 [,索引号][,源数组]){}, 起始值)`
* 起始值可以省略，如果有则作为第一次累计的起始值

* ![3](images\js\3.png)
* 伪数组转换为真数组：静态方法 Array.from()

##### 3、String

![4](images\js\4.png)

##### 4、Number

常用方法：toFixed(保留位数) 设置保留小数位的长度

### 原型

#### 原型

* 每一个构造函数都有一个 prototype 属性，指向另一个对象，这个对象称为原型对象
* 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
* 直接定义在 prototype 对象上的方法，可以被该构造函数的实例所共享
* 构造函数和原型对象中的this 都指向 实例化的对象

#### constructor 属性

* 每个原型对象里面都有个constructor 属性，指向该原型对象的构造函数

* 使用场景：

  ```js
  function Star(name){
      this.name = name
  }
  Star.prototype = {
      // 因为这里采用赋值的方式给prototype创建方法，它原指向的构造函数会被覆盖，导致它的constructor会指向Object，所以需要手动将其指回原有的构造函数Star
      constructor: Star,
      sing: function(){ console.log('唱歌') },
      dance: function(){ console.log('跳舞') }
  }
  ```

#### 对象原型

* 实例对象都会有一个属性 \__proto__ 指向构造函数的 prototype 原型对象
* 实例对象通过属性 \__proto__，从而找到共享的 prototype 原型对象，使用其属性和方法

#### 原型继承

```js
function People(){
    // 公共的属性和方法
}
function Man(){}
// 继承Person对象
Man.prototype = new Person()
// 指回自己
Man.prototype.constructor = Man
function Woman(){}
Woman.prototype = new Person()
Woman.prototype.constructor = Woman
```

#### 原型链

![5](images\js\5.png)

查找规则

* 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
* 如果没有就查找它的原型（也就是\__proto__指向的 prototype 原型对象）
* 如果还没有就查找原型对象的原型（Object的原型对象）
* 依此类推一直找到 Object 为止（null）
* \__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线
* 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上



# ES6

### ECMASript 6 新特性

#### let关键字

let 关键字用来声明变量，使用let 声明的变量有几个特点： 

* 不允许重复声明 
* 块儿级作用域 
* 不存在变量提升 
* 不影响作用域链 

应用场景：以后声明变量使用let 就对了 

#### const 关键字 

const 关键字用来声明常量，const 声明有以下特点

* 声明必须赋初始值 
* 标识符一般为大写
* 不允许重复声明
* 值不允许修改 
* 块儿级作用域 

注意: 对象属性修改和数组元素变化不会出发const 错误

应用场景：声明对象类型使用const，非对象类型声明选择let 

#### 变量的解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。

* 数组的解构赋值
* 对象的解构赋值
* 复杂解构

#### 模板字符串

模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点： 

* 字符串中可以出现换行符 
* 可以使用 ${xxx} 形式输出变量

#### 简化对象写法 

ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 

#### 箭头函数 

箭头函数的注意点: 

* 如果形参只有一个，则小括号可以省略 
* 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果 
* 箭头函数this 指向声明时所在作用域下 this 的值 
* 箭头函数不能作为构造函数实例化 
* 不能使用arguments 

#### rest 参数

ES6 引入rest 参数，用于获取函数的实参，用来代替arguments，即剩余参数`...args`

#### spread 扩展运算符

将一个数组转为用逗号分隔的参数序列，对数组进行解包。 

* 展开数组
* 展开对象

#### Symbol

##### 1、Symbol 基本使用

ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。

特点：

* Symbol 的值是唯一的，用来解决命名冲突的问题 
* Symbol 值不能与其他数据进行运算 
* Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用Reflect.ownKeys 来获取对象的所有键名 

##### 2、Symbol 内置值 

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| Symbol.hasInstance        | 当其他对象使用instanceof 运算符，判断是否为该对象的实例时，会调用这个方法 |
| Symbol.isConcatSpreadable | 对象的Symbol.isConcatSpreadable 属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 |
| Symbol.species            | 创建衍生对象时，会使用该属性                                 |
| Symbol.match              | 当执行str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值。 |
| Symbol.replace            | 当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.search             | 当该对象被str. search (myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.split              | 当该对象被str. split (myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.iterator           | 对象进行for...of 循环时，会调用Symbol.iterator 方法，返回该对象的默认遍历器 |
| Symbol.toPrimitive        | 该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 |
| Symbol. toStringTag       | 在该对象上面调用toString 方法时，返回该方法的返回值          |
| Symbol. unscopables       | 该对象指定了使用with 关键字时，哪些属性会被with环境排除。    |

#### 迭代器

* ES6 创造了一种新的遍历命令for...of 循环，Iterator 接口主要供for...of 消费 
* 原生具备iterator 接口的数据(可用for of 遍历) 
  * Array、Arguments、Set、Map、String、TypedArray 、NodeList 
* 工作原理
  * 创建一个指针对象，指向当前数据结构的起始位置 
  * 第一次调用对象的next 方法，指针自动指向数据结构的第一个成员 
  * 接下来不断调用next 方法，指针一直往后移动，直到指向最后一个成员 
  * 每调用next 方法返回一个包含value 和done 属性的对象

#### 生成器

生成器函数是ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同 

```js
function * gen(){ 
    yield '一只没有耳朵'; 
    yield '一只没有尾巴'; 
    return '真奇怪'; 
} 
let iterator = gen(); 
console.log(iterator.next()); 
console.log(iterator.next()); 
console.log(iterator.next()); 
```

代码说明： 

* \* 的位置没有限制 
* 生成器函数返回的结果是迭代器对象，调用迭代器对象的next 方法可以得到yield 语句后的值 
* yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次next方法，执行一段代码 
* next 方法可以传递实参，作为yield 语句的返回值 

#### Promise

Promise 是ES6 引入的异步编程的新解决方案。语法上Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。 

* Promise 构造函数: Promise (excutor) {}
* Promise.prototype.then 方法 
* Promise.prototype.catch 方法 

#### Set

集合的属性和方法： 

* size、add、delete、has、clear

#### Map

Map的属性和方法： 

* size、set、get、has、clear

#### class 类

```js
//父类 
class Phone { 
    //构造方法 
    constructor(brand, color, price) { 
        this.brand = brand; 
        this.color = color; 
        this.price = price; 
    } 
    
    //对象方法 
    call() { 
        console.log('我可以打电话!!!') 
    } 
} 

//子类 
class SmartPhone extends Phone { 
 
    constructor(brand, color, price, screen, pixel) { 
        super(brand, color, price); 
        this.screen = screen; 
        this.pixel = pixel; 
    } 
 
    //子类方法 
    photo(){ 
        console.log('我可以拍照!!'); 
    } 

 
    //方法重写 
    call(){ 
        console.log('我可以进行视频通话!!'); 
    } 
 
    //静态方法 
    static run(){ 
        console.log('我可以运行程序') 
    } 
 
    static connect(){ 
        console.log('我可以建立连接') 
    } 
} 
```

#### 数值扩展

##### 1、二进制和八进制

ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b 和0o 表示。 

##### 2、Number.isFinite() 与Number.isNaN()

Number.isFinite() 用来检查一个数值是否为有限的

Number.isNaN() 用来检查一个值是否为NaN 

##### 3、Number.parseInt() 与Number.parseFloat() 

ES6 将全局方法parseInt 和parseFloat，移植到Number 对象上面，使用不变。 

##### 4、Math.trunc 

用于去除一个数的小数部分，返回整数部分。 

##### 5、Number.isInteger 

Number.isInteger() 用来判断一个数值是否为整数 

#### 对象扩展

ES6 新增了一些Object 对象的方法 

* Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）
* Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象 
* \__proto__、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型 

#### 模块化

模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。

模块功能主要由两个命令构成：export 和import。 

* export 命令用于规定模块的对外接口 
* import 命令用于输入其他模块提供的功能 

### ECMASript 7 新特性 

#### Array.prototype.includes 

Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值 

#### 指数操作符

在ES7 中引入指数运算符「**」，用来实现幂运算，功能与Math.pow 结果相同

### ECMASript 8 新特性

#### async 和await

async 和await 两种语法结合可以让异步代码像同步代码一样 

##### 1、async 函数 

1. async 函数的返回值为promise 对象， 
2. promise 对象的结果由async 函数执行的返回值决定 

##### 2、await 表达式 

1. await 必须写在async 函数中
2. await 右侧的表达式一般为promise 对象 
3. await 返回的是promise 成功的值 
4. await 的promise 失败了, 就会抛出异常, 需要通过try...catch 捕获处理 

#### Object.values 和Object.entries 

1. Object.values()方法返回一个给定对象的所有可枚举属性值的数组 
2. Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组 

#### Object.getOwnPropertyDescriptors 

该方法返回指定对象所有自身属性的描述对象 

### ECMASript 9 新特性

#### 正则表达式命名捕获组 

ES9 允许命名捕获组使用符号『?\<>』,这样获取捕获结果可读性更强 

```js
let str = '<a href="http://www.atguigu.com">尚硅谷</a>'; 
const reg = /<a href="(?<url>.*)">(?<text>.*)<\/a>/; 
const result = reg.exec(str); 
console.log(result.groups.url); 
console.log(result.groups.text); 
```

#### 正则表达式反向断言

ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。符号(?<>=xx)

```js
//声明字符串 
let str = 'JS5211314你知道么555啦啦啦'; 
//正向断言 
const reg = /\d+(?=啦)/; 
const result = reg.exec(str); 
 
//反向断言 
const reg = /(?<=么)\d+/; 
const result = reg.exec(str); 
 
console.log(result); 
```

#### 正则表达式dotAll 模式

正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现 

```js
let str = ` 
<ul> 
    <li> 
        <a>肖生克的救赎</a> 
        <p>上映日期: 1994-09-10</p> 
    </li> 
    <li> 
        <a>阿甘正传</a> 
        <p>上映日期: 1994-07-06</p> 
    </li> 
</ul>`; 
//声明正则,?为非贪婪模式，默认情况下，量词是 贪婪的（尽可能多匹配），而 ? 会使其变为 尽可能少匹配。
const reg = /<li>.*?<a>(.*?)<\/a>.*?<p>(.*?)<\/p>/gs; 
//执行匹配 
const result = reg.exec(str); 
let result; 
let data = []; 
while(result = reg.exec(str)){ 
    data.push({title: result[1], time: result[2]}); 
} 
//输出结果 
console.log(data); 
```

### ECMASript 10 新特性 

#### Object.fromEntries 

#### trimStart 和trimEnd 

#### Array.prototype.flat 与 flatMap

#### Symbol.prototype.description

### ECMASript 11 新特性 

#### String.prototype.matchAll 

#### 类的私有属性 

#### Promise.allSettled 

#### 可选链操作符 

#### 动态import 导入 

#### globalThis 对象 



# AJAX

### AJAX 的特点

#### AJAX 的优点

* 可以无需刷新页面而与服务器端进行通信。
* 允许你根据用户事件来更新部分页面内容。

#### AJAX 的缺点

* 没有浏览历史，不能回退
* 存在跨域问题(同源)
* SEO 不友好（对爬虫不友好）

###  AJAX 的使用

#### 核心对象

XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。

#### 使用步骤

1. 创建 XMLHttpRequest 对象
   `var xhr = new XMLHttpRequest();`

2. 设置请求信息

   ```js
   xhr.open(method, url);
   //可以设置请求头，一般不设置
   xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
   ```

3. 发送请求

   `hr.send(body) //get 请求不传 body 参数，只有 post 请求使用`

4. 接收响应

   ```js
   //xhr.responseXML 接收 xml 格式的响应数据
   //xhr.responseText 接收文本格式的响应数据
   
   xhr.onreadystatechange = function (){
       if(xhr.readyState == 4 && xhr.status == 200){
           var text = xhr.responseText;
       	console.log(text);
       }
   }
   ```

###  解决 IE 缓存问题

* 问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。
* 解决方式：浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题
* `xhr.open("get","/testAJAX?t="+Date.now());`

### AJAX 请求状态

xhr.readyState 可以用来查看请求当前的状态
https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState

* 0: 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有被调用。
* 1: 表示 send()方法还没有被调用，仍然可以使用 setRequestHeader()，设定 HTTP请求的头信息。
* 2: 表示 send()方法已经执行，并且头信息和状态码已经收到。
* 3: 表示正在接收服务器传来的 body 部分的数据。
* 4: 表示服务器数据已经完全接收，或者本次接收已经失败了

### jQuery 中的 AJAX

#### get 请求

`$.get(url, [data], [callback], [type])`

* url:请求的 URL 地址。
* data:请求携带的参数。
* callback:载入成功时回调函数。
* type:设置返回内容格式，xml, html, script, json, text, _default。

#### post 请求

`$.post(url, [data], [callback], [type])`

* url:请求的 URL 地址。
* data:请求携带的参数。
* callback:载入成功时回调函数。
* type:设置返回内容格式，xml, html, script, json, text, _default。

### 跨域

#### 同源策略

同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。

同源： 协议、域名、端口号 必须完全相同。

违背同源策略就是跨域。

#### 解决跨域——JSONP

##### 1、JSONP 是什么

JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。

##### 2、JSONP 怎么工作的？

在网页有一些标签天生具有跨域能力，比如：img link iframe script。
JSONP 就是利用 script 标签的跨域能力来发送请求的。

##### 3、JSONP 的使用

1. 动态的创建一个 script 标签

   `var script = document.createElement("script");`

2. 设置 script 的 src，设置回调函数

   ```js
   script.src = "http://localhost:3000/testAJAX?callback=abc";
   function abc(data) {
   	alert(data.name);
   };
   ```

3. 将 script 添加到 body 中

   `document.body.appendChild(script);`

4. 服务器中路由的处理

   ```js
   router.get("/testAJAX" , function (req , res) {
   	console.log("收到请求");
   	var callback = req.query.callback;
   	var obj = {
           name:"孙悟空",
   		age:18
       }
       res.send(callback+"("+JSON.stringify(obj)+")");
   });
   ```

##### jQuery 中的 JSONP

#### 解决跨域——CORS

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS

##### 1、CORS 是什么？

CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源

##### 2、CORS 怎么工作的？

CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。

##### 3、CORS 的使用

主要是服务器端的设置：

```js
router.get("/testAJAX" , function (req , res) {
    //通过 res 来设置响应头，来允许跨域请求
	//res.set("Access-Control-Allow-Origin","http://127.0.0.1:3000");
	res.set("Access-Control-Allow-Origin","*");
	res.send("testAJAX 返回的响应");
});
```

